<html lang="en"><head><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (typeof arg === 'object') {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    const errorString = stringifyArgs(args);
    window.parent.postMessage({ type: 'error', message: errorString }, '*');
    originalConsoleError.apply(console, args);
  };

  window.addEventListener('error', function(event) {
    const errorString = event.message + ' (' + event.filename + ':' + event.lineno + ':' + event.colno + ') ' + (event.error ? event.error.stack : '');
    window.parent.postMessage({ type: 'error', message: errorString }, '*');
  });

})();</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FortHex</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&family=Geostar&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Exo 2', sans-serif;
            background-color: #2c3e50;
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; 
            min-height: 100vh;
            margin: 0;
            padding-top: 20px;
            padding-bottom: 100px;
            box-sizing: border-box; 
        }
        h1.text-4xl {
             font-family: 'Geostar', cursive;
        }

        #gameLayoutContainer {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
            max-width: 1400px;
            padding-left: 10px;
            padding-right: 10px;
            box-sizing: border-box;
        }
        canvas {
            background-color: #34495e;
            border-radius: 10px;
            display: block;
            cursor: default;
            touch-action: none;
        }

        .ui-panel {
            background-color: #34495e;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ecf0f1;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 0 0 280px;
            box-sizing: border-box;
            min-height: 595px;
            justify-content: flex-start;
        }

        #turnDisplay {
            font-size: 1.5em;
            margin-bottom: 0;
            color: #f1c40f;
            text-align: center;
        }

        .ui-panel p {
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .buttons-container { /* This container is for End Turn Button */
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: auto; /* Pushes End Turn to bottom of right panel */
            padding-top: 15px;
        }
        .ui-panel .buttons-container button { /* End Turn specifics */
             background-color: #e74c3c;
             box-shadow: 0 3px #c0392b;
             color: white;
             border: none;
             padding: 10px 15px;
             border-radius: 5px;
             font-family: 'Exo 2', sans-serif;
             cursor: pointer;
             transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
             display: flex;
             align-items: center;
             justify-content: center;
             gap: 8px;
        }
        .ui-panel .buttons-container button:hover:not(:disabled) {
            background-color: #c0392b;
        }
         .ui-panel .buttons-container button:active:not(:disabled) {
            box-shadow: none;
            transform: translateY(3px);
        }

        #generateMapButtonContainer {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-top: 20px; /* Space above button container */
            margin-bottom: 20px; /* Space below button container */
        }

        #generateMapButton {
            background-color: #f1c40f; 
            box-shadow: 0 3px #d4ac0d; 
            width: 280px; /* Set specific width */
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        #generateMapButton:hover:not(:disabled) {
            background-color: #d4ac0d;
        }
        #generateMapButton:active:not(:disabled) {
            box-shadow: none;
            transform: translateY(3px);
        }
         #generateMapButton svg {
            width: 20px;
            height: 20px;
            stroke: white;
        }


        #downloadButton {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
            box-shadow: 0 4px #1e8449;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 1001;
        }
        #downloadButton:hover:not(:disabled) {
            background-color: #229954;
            box-shadow: 0 4px #196f3d;
        }
        #downloadButton:active:not(:disabled) {
            box-shadow: 0 1px #196f3d;
            transform: translateY(3px);
        }
        #downloadButton svg {
            width: 28px;
            height: 28px;
            stroke: white;
        }

        #tutorialButton {
            position: fixed;
            bottom: 90px; 
            left: 20px;
            width: 60px;
            height: 60px;
            background-color: #8e44ad; 
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
            box-shadow: 0 4px #732d91; 
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 1002;
        }
        #tutorialButton:hover:not(:disabled) {
            background-color: #732d91;
            box-shadow: 0 4px #512066;
        }
        #tutorialButton:active:not(:disabled) {
            box-shadow: 0 1px #512066;
            transform: translateY(3px);
        }
        #tutorialButton svg {
            width: 32px; 
            height: 32px;
            fill: white; 
        }


        .action-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 3px #2980b9;
            margin-left: 5px;
            margin-right: 5px;
        }
        .action-button.selecting {
            background-color: #f39c12;
            box-shadow: 0 3px #d35400;
        }
        .action-button.selecting:hover {
            background-color: #d35400;
        }
        .action-button:not(.selecting):hover:not(:disabled) {
             background-color: #2980b9;
        }
        .action-button:disabled {
            background-color: #95a5a6;
            color: #bdc3c7;
            cursor: not-allowed;
            box-shadow: 0 3px #7f8c8d;
        }
        .action-button:active:not(:disabled) {
             box-shadow: none;
            transform: translateY(3px);
        }

        .unit-info-container {
            width: 100%;
        }
        .unit-info-container p { font-size: 1em; margin: 4px 0; }

        .actions-panel {
            padding-top: 10px;
            border-top: 1px solid #7f8c8d;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            width: 100%;
        }
        .actions-panel h3 {
            font-size: 1.em;
            margin-bottom: 10px;
            color: #f1c40f;
            width: 100%;
            text-align: center;
        }
        .message-box {
            position: fixed; top: 20px; left: 50%;
            transform: translateX(-50%); background-color: #e74c3c;
            color: white; padding: 15px 25px; border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 1000;
            font-size: 1em; display: none;
            text-align: center;
            max-width: 90%;
        }
        .victory-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2ecc71;
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            z-index: 2000;
            font-size: 2em;
            text-align: center;
            display: none;
        }
        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none; 
            align-items: center;
            justify-content: center;
            z-index: 3000; 
            opacity: 0; 
            visibility: hidden; 
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
        }
        .modal-overlay.modal-visible { 
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0s; 
        }

        .modal-content {
            background-color: #34495e;
            padding: 25px 30px;
            border-radius: 10px;
            border: 2px solid #ecf0f1;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: 90%;
            max-width: 400px;
            color: #ecf0f1;
        }
        .modal-content p {
            font-size: 1.1em;
            margin-bottom: 20px;
        }
        .modal-buttons {
            display: flex;
            justify-content: space-around;
            gap: 15px;
        }
        .modal-buttons button {
            font-family: 'Exo 2', sans-serif;
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s, box-shadow 0.3s;
            color: white;
        }
        .modal-button-ok {
            background-color: #27ae60;
            box-shadow: 0 3px #1e8449;
        }
        .modal-button-ok:hover {
            background-color: #229954;
        }
        .modal-button-cancel {
            background-color: #e74c3c;
            box-shadow: 0 3px #c0392b;
        }
        .modal-button-cancel:hover {
            background-color: #c0392b;
        }

        /* Tutorial Modal Styles */
        #tutorialModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.7); 
            -webkit-backdrop-filter: blur(3px); 
            backdrop-filter: blur(3px);
            display: none; 
            align-items: center;
            justify-content: center;
            z-index: 2900; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s; 
        }
        #tutorialModalOverlay.modal-visible { 
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0s; 
        }

        #tutorialModalContent {
            background-color: #34495e;
            padding: 20px 30px;
            border-radius: 10px;
            border: 2px solid #ecf0f1;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            color: #ecf0f1;
            width: 90%;
            max-width: 700px; 
            max-height: 80vh; 
            overflow-y: auto;
            position: relative; 
            text-align: left; 
        }
        #tutorialModalContent h2 {
            font-family: 'Geostar', cursive;
            font-size: 2em;
            text-align: center;
            margin-bottom: 15px;
            color: #f1c40f;
        }
        #tutorialModalContent p, #tutorialModalContent li {
            font-size: 0.95em;
            margin-bottom: 10px;
            line-height: 1.6;
        }
        #tutorialModalContent strong {
            color: #f1c40f;
        }
        #tutorialModalContent ul {
            list-style-type: disc;
            padding-left: 20px;
            margin-bottom:10px;
        }
        .tutorial-modal-close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #ecf0f1;
            font-size: 2em;
            cursor: pointer;
            line-height: 1;
        }
        .tutorial-modal-close-button:hover {
            color: #f1c40f;
        }
        .tutorial-section {
            margin-bottom: 15px;
            border-bottom: 1px solid #4a6075;
            padding-bottom: 10px;
        }
        .tutorial-section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .tutorial-section-header {
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            padding: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #1abc9c; 
        }
        .tutorial-section-header:hover {
            color: #16a085;
        }
        .tutorial-section-content {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            padding-left: 15px; 
            padding-top: 0px; 
            transition: max-height 0.35s ease-in-out, opacity 0.3s ease-in-out, padding-top 0.35s ease-in-out;
        }
        .tutorial-section-content.open {
            opacity: 1;
            padding-top: 5px; 
             max-height: 1000px; 
        }
        .tutorial-arrow {
            font-size: 0.8em;
            margin-left: 10px;
            transition: transform 0.2s ease-in-out;
        }
        .tutorial-section-header.active .tutorial-arrow {
            transform: rotate(90deg);
        }

        .action-info-header {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #f1c40f;
            width: 100%;
            text-align: center;
            font-weight: bold;
        }
        
        #actionInfoContainer {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #actionLogContent {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px; 
            margin-right: -10px; 
            min-height: 120px;
            display: flex;
            flex-direction: column; 
            justify-content: flex-start;
        }

        #actionLogContent::-webkit-scrollbar {
            width: 8px;
        }
        #actionLogContent::-webkit-scrollbar-track {
            background: #2c3e50;
            border-radius: 4px;
        }
        #actionLogContent::-webkit-scrollbar-thumb {
            background: #4a6075;
            border-radius: 4px;
        }
        #actionLogContent::-webkit-scrollbar-thumb:hover {
            background: #5e7a97;
        }
        .log-entry {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 8px;
            background-color: #2c3e50;
            border-radius: 4px;
            margin-top: 5px;
            animation: fadeIn 0.3s ease-in-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .log-entry.log-p1 {
            border: 2px solid #5dade2; 
        }
        .log-entry.log-p2 {
            border: 2px solid #e74c3c; 
        }

        .log-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            margin-top: 0px;
        }
        .log-message {
            font-size: 0.9em;
            line-height: 1.5;
            color: #bdc3c7;
            word-break: break-word;
        }
        .log-message strong { font-weight: bold; }
        .p1-log { color: #5dade2 !important; } 
        .p2-log { color: #e74c3c !important; }
        .log-message .damage-text { color: #f1c40f; }
        .log-message .heal-text { color: #2ecc71; }
        .log-message .shield-text { color: #30C4C4; }
        .log-message .advantage-text { color: #2ecc71; }
        .log-message .disadvantage-text { color: #e74c3c; }
        .log-message .keyword-text { color: #f39c12; }

        .respawn-queue-container {
            border-top: 1px solid #7f8c8d;
            padding-top: 15px;
            margin-top: 15px;
            margin-top: auto;
        }
        .respawn-queue-header {
            text-align: center;
            color: #f1c40f;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .respawn-queue-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .respawn-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: #2c3e50;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .respawn-unit-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .respawn-unit-symbol {
            font-weight: bold;
            font-size: 1.2em;
        }
        .respawn-timer {
            font-weight: bold;
            color: #f1c40f;
        }

        /* RESPAWN MODAL STYLES */
        #respawnModalContent {
            text-align: center;
            width: auto;
            max-width: 500px;
            /* Border color will be set by JS */
            transition: border-color 0.3s ease-in-out; 
        }
        #respawnModalContent.modal-p1 { border-color: #5dade2; }
        #respawnModalContent.modal-p2 { border-color: #e74c3c; }

        #respawnModalContent h3 {
            font-family: 'Geostar', cursive;
            font-size: 1.8em;
            color: #f1c40f;
            margin-bottom: 10px;
        }
        #respawnModalContent p {
            font-size: 1.1em;
            margin-bottom: 20px;
        }
        #respawnChoices {
            display: flex; 
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .respawn-button {
            background-color: #27ae60; 
            color: white;
            border: none;
            width: 70px;
            height: 70px;
            border-radius: 50%; 
            font-family: 'Exo 2', sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.2s;
            box-shadow: 0 4px #1e8449; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .respawn-button svg {
            width: 40px;
            height: 40px;
            stroke: white;
            fill: white;
        }
        .respawn-button:hover:not(:disabled) {
            background-color: #229954;
            transform: translateY(-2px);
        }
        .respawn-button:active:not(:disabled) {
            transform: translateY(2px);
            box-shadow: 0 1px #1e8449;
        }
        .respawn-button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
            box-shadow: 0 4px #525a5b;
            opacity: 0.6;
        }

    </style>
    <style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.mb-6{margin-bottom:1.5rem}.text-center{text-align:center}.text-4xl{font-size:2.25rem;line-height:2.5rem}.font-bold{font-weight:700}.text-amber-400{--tw-text-opacity:1;color:rgb(251 191 36 / var(--tw-text-opacity, 1))}</style>
</head>
<body>
    <h1 class="text-4xl font-bold mb-6 text-center text-amber-400">FortHex</h1>
    <div id="gameLayoutContainer">
        <div id="leftPanel" class="ui-panel">
            <div>
                <div id="globalTurnCounterDisplay" class="text-center" style="font-size: 1.5em; color: #f1c40f;">Turn: 1</div>
                <hr style="width: 100%; border-color: #7F8C8D; margin-top: 10px;">
            </div>
            <div id="selectedUnitInfoContainer" class="unit-info-container" style="display: none;">
                <div id="selectedUnitInfo">
                    <p><strong>Selected Unit:</strong> <span id="unitName"></span></p>
                    <p><strong>HP:</strong> <span id="unitHP"></span>/<span id="unitMaxHP"></span></p>
                    <p><strong>Movement:</strong> <span id="unitMovement"></span></p>
                    <p><strong>Position:</strong> <span id="unitPosition"></span></p>
                    <p><strong>Status:</strong> <span id="unitStatus"></span></p>
                </div>
            </div>
             <!-- ACTION INFO PANEL STRUCTURE -->
            <div id="actionInfoContainer" class="unit-info-container">
                <h3 class="action-info-header">Action Log</h3>
                <div id="actionLogContent">
                    <!-- Action messages will be populated here by JavaScript -->
                </div>
            </div>
            <!-- END OF STRUCTURE -->
            <!-- UNIFIED Respawn Queue Display -->
            <div id="reinforcementsContainer" class="respawn-queue-container" style="display: none;">
                <h4 class="respawn-queue-header">Reinforcements</h4>
                <div id="reinforcementsList" class="respawn-queue-list"></div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="rightPanel" class="ui-panel">
            <h2 id="turnDisplay">Player 1's Turn</h2>
            <div id="actionsPanel" class="actions-panel" style="display: none;">
                <h3>Actions</h3>
                <button id="fortifyUnfortifyButton" class="action-button">Fortify</button>
                <button id="buildBridgeButton" class="action-button">Build Bridge</button>
                <button id="attackButton" class="action-button">Attack</button>
            </div>
            <div class="buttons-container">
                <button id="endTurnButton">End Turn</button>
            </div>
        </div>
    </div>

    <div id="generateMapButtonContainer">
        <button id="generateMapButton">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21.5 2v6h-6M2.5 22v-6h6"/>
                <path d="M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/>
            </svg>
            Generate New Map
        </button>
    </div>

    <button id="tutorialButton" title="Game Tutorial">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/>
        </svg>
    </button>

    <button id="downloadButton" title="Download Game">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
    </button>

    <div id="messageBox" class="message-box" style="display: none;">Project Hexblade Loaded. Player 1's Turn.</div>
    <div id="victoryMessage" class="victory-message" style="display: none;"></div>

    <div id="customConfirmModal" class="modal-overlay" style="display: none;"> <!-- Will be controlled by JS -->
        <div class="modal-content">
            <p id="customConfirmMessage">Are you sure you want to generate a new map? This will reset the current game.</p>
            <div class="modal-buttons">
                <button id="customConfirmOkButton" class="modal-button-ok">Confirm</button>
                <button id="customConfirmCancelButton" class="modal-button-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <div id="tutorialModalOverlay" style="display: none;"> <!-- Will be controlled by JS -->
        <div id="tutorialModalContent">
            <button id="tutorialCloseButton" class="tutorial-modal-close-button" title="Close Tutorial">&times;</button>
            <h2>FortHex: Introduction & Tutorial</h2>
            <p>Welcome to FortHex! This guide will explain the core mechanics and features of the game.</p>
            <p><strong>Objective:</strong> The primary goal in FortHex is to eliminate all of your opponent's units.</p>
            <p><strong>Gameplay:</strong> FortHex is a turn-based strategy game played on a hexagonal grid. Each player controls a set of units, taking turns to move them and perform actions.</p>

            <div class="tutorial-section">
                <div class="tutorial-section-header">1. The Game Board: Tiles & Edges <span class="tutorial-arrow">&#9658;</span></div>
                <div class="tutorial-section-content">
                    <p>The battlefield is composed of hexagonal tiles and the edges between them.</p>
                    <p><strong>1.1 Tile Types:</strong><br>Each tile has unique properties affecting gameplay:</p>
                    <ul>
                        <li><strong>Plains:</strong>
                            <ul>
                                <li>Movement Cost: 1 MP (Movement Point).</li>
                                <li>Fortifiable: Yes.</li>
                                <li>Line of Sight (LOS): Does not block LOS.</li>
                            </ul>
                        </li>
                        <li><strong>Forest:</strong>
                            <ul>
                                <li>Movement Cost: 2 MP.</li>
                                <li>Fortifiable: Yes.</li>
                                <li>Line of Sight (LOS): Blocks LOS. Units cannot see <em>through</em> a forest tile unless they are on an edge of that forest tile or fortified within it.</li>
                                <li><strong>Hidden Fortification:</strong> A unit fortified in a Forest tile is considered "hidden." It can only be targeted by archers on an edge immediately adjacent to that forest, or by melee units from an adjacent edge. Archers outside this immediate vicinity cannot target a unit hidden in a forest fortification.</li>
                            </ul>
                        </li>
                        <li><strong>Water:</strong>
                            <ul>
                                <li>Movement Cost: Impassable.</li>
                                <li>Fortifiable: No.</li>
                                <li>Line of Sight (LOS): Does not block LOS.</li>
                                <li>Crossable: Only via a Bridge.</li>
                            </ul>
                        </li>
                        <li><strong>Mountain:</strong>
                            <ul>
                                <li>Movement Cost: 3 MP.</li>
                                <li>Fortifiable: No.</li>
                                <li>Line of Sight (LOS): Blocks LOS. Units cannot see <em>through</em> a mountain tile.</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>1.2 Edges:</strong><br>Edges are the boundaries between two adjacent hexagonal tiles.</p>
                    <ul>
                        <li><strong>Unit Position:</strong> Units are primarily positioned <em>on edges</em>.</li>
                        <li><strong>Capacity:</strong> Up to two friendly units can occupy the same edge. Enemy units cannot share an edge with your units.</li>
                        <li><strong>Bridges:</strong>
                            <ul>
                                <li>Can be built by Melee units over Water edges.</li>
                                <li>Cost: 1 action point.</li>
                                <li>Health: Bridges have 5 HP (BRIDGE_MAX_HP).</li>
                                <li>Movement: Allow movement across water as if it were a Plains edge (1 MP cost).</li>
                                <li>Destroyable: Can be attacked and destroyed by units. If a bridge is destroyed, any units on it are eliminated.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">2. Units & Stats <span class="tutorial-arrow">&#9658;</span></div>
                <div class="tutorial-section-content">
                    <p>Each player controls two types of units: Melee and Archer.</p>
                    <p><strong>2.1 General Unit Stats:</strong></p>
                    <ul>
                        <li><strong>HP (Health Points):</strong> Represents the unit's health. If a unit's HP reaches 0, it is destroyed and removed from the game.</li>
                        <li><strong>Max HP:</strong> The normal maximum health of the unit.</li>
                        <li><strong>Movement Points (MP):</strong> The distance a unit can travel in a turn. MP is spent moving between edges. Refreshes at the start of your turn.</li>
                        <li><strong>Attack:</strong> The base amount of damage a unit deals when attacking.</li>
                        <li><strong>Player Color:</strong> Player 1 units are typically blue; Player 2 units are red.</li>
                    </ul>
                    <p><strong>2.2 Unit Types:</strong></p>
                    <ul>
                        <li><strong>Melee Unit:</strong>
                            <ul>
                                <li>HP: 12</li>
                                <li>Base Movement: 4 MP</li>
                                <li>Attack: 3</li>
                                <li>Special Ability: Can perform the "Build Bridge" action.</li>
                                <li>Attack Type: Attacks targets on rotationally adjacent edges or adjacent fortified units.</li>
                            </ul>
                        </li>
                        <li><strong>Archer Unit:</strong>
                            <ul>
                                <li>HP: 10</li>
                                <li>Base Movement: 3 MP</li>
                                <li>Attack: 2</li>
                                <li>Special Ability: Ranged attack.</li>
                                <li>Attack Type: Attacks targets within its range and Line of Sight.
                                    <ul>
                                        <li><strong>Fortified Archer Bonus:</strong> Gains +1 Attack if attacking while fortified.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">3. Player Turn & Unit Actions <span class="tutorial-arrow">&#9658;</span></div>
                <div class="tutorial-section-content">
                    <p>During your turn, each of your units can typically perform one "major action" (Attack, Fortify, Unfortify, Build Bridge) OR use its Movement Points to move. Once a major action is performed, the unit cannot move further or perform another major action in that turn (though it might still have MP remaining).</p>
                    <p><strong>3.1 Movement:</strong></p>
                    <ul>
                        <li>Units move from one edge to another rotationally adjacent edge.</li>
                        <li><strong>Movement Point Costs per Edge Traversed:</strong>
                            <ul>
                                <li>Plains Edge (both tiles Plains): 1 MP</li>
                                <li>Forest Edge (at least one tile Forest, neither Water/Mountain): 2 MP</li>
                                <li>Mountain Edge (at least one tile Mountain, neither Water): 3 MP</li>
                                <li>Bridged Water Edge: 1 MP</li>
                                <li>Unbridged Water Edge: Impassable.</li>
                            </ul>
                        </li>
                        <li><strong>Enemy Fortification Penalty:</strong> Moving onto an edge adjacent to an enemy-controlled fortified tile costs an additional +1 MP. This penalty stacks with terrain costs.</li>
                        <li><strong>Maximum Movement Cost:</strong> Regardless of terrain and fortification penalties, the cost to move onto a single adjacent edge will not exceed 3 MP (MAX_MOVEMENT_COST).</li>
                    </ul>
                    <p><strong>3.2 Attack Action:</strong></p>
                    <ul>
                        <li>Cost: 1 MP.</li>
                        <li>Ends the unit's ability to perform other major actions or move further that turn.</li>
                        <li><strong>Targets:</strong> Enemy units or enemy-controlled/neutral bridges.</li>
                        <li><strong>Melee Attack:</strong>
                            <ul>
                                <li>Can target enemy units on any rotationally adjacent edge.</li>
                                <li>Can target an enemy unit fortified on a tile adjacent to the Melee unit's current edge (unless the target is "hidden" in a Forest fortification and the Melee unit is not on an edge of that specific forest).</li>
                                <li>Can target bridges on rotationally adjacent edges.</li>
                            </ul>
                        </li>
                        <li><strong>Archer Attack:</strong>
                            <ul>
                                <li><strong>Range:</strong> Archers can generally target edges around the two hexes they straddle, and one hex beyond that, subject to Line of Sight.</li>
                                <li><strong>Line of Sight (LOS) Rules:</strong>
                                    <ul>
                                        <li><strong>General Blockers:</strong> Mountains always block LOS. Forests block LOS if the archer is not on an edge of that forest or fortified within it.</li>
                                        <li><strong>Archer on an Edge:</strong>
                                            <ul>
                                                <li>The archer uses both tiles it straddles (Tile A and Tile B) for LOS determination.</li>
                                                <li>To see a target edge: LOS must be clear from <em>both</em> Tile A and Tile B to the target edge. For example, if Tile A is a Forest, and the target edge is not rotationally adjacent to the archer's edge <em>on Tile A</em>, then Tile A blocks LOS from that "side." The same applies to Tile B. If <em>either</em> side is blocked by terrain like this, the shot is not possible. Mountains on Tile A or Tile B will block shots to edges <em>behind</em> that mountain relative to the archer.</li>
                                                <li>To see a fortified unit: Similar rules apply. The archer must be able to "see" the tile the target is fortified on, considering the terrain of Tile A and Tile B and requiring rotational adjacency for shots originating from forest hexes. An archer on an edge cannot shoot into a "hidden" (Forest) fortification.</li>
                                            </ul>
                                        </li>
                                        <li><strong>Fortified Archer (Plains/Mountain):</strong> Has a clear view of its own tile and all 6 adjacent tiles, and can shoot at units/bridges on edges connecting these tiles, or fortified units on these tiles, provided intervening terrain (further away Mountains/Forests) doesn't block LOS.</li>
                                        <li><strong>Fortified Archer (Forest - "Hidden"):</strong>
                                            <ul>
                                                <li>Can only shoot at units on edges immediately adjacent to its own forest tile.</li>
                                                <li>Can only shoot at fortified units on tiles immediately adjacent to its own forest tile (if the target is not <em>also</em> in a Forest fortification).</li>
                                                <li>Is "hidden" and cannot be targeted by enemy archers unless they are on an edge immediately adjacent to this archer's forest tile.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li><strong>Split Damage:</strong> If an Archer attacks an enemy unit on an edge where <em>two</em> enemy units are present (and the primary target is not fortified), the Archer's damage is split between both enemy units (e.g., 2 damage becomes 1 damage to each). Each unit takes a minimum of 1 damage if the Archer's attack is 1.</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>3.3 Fortify Action:</strong></p>
                    <ul>
                        <li>Cost: 1 MP.</li>
                        <li>Ends the unit's ability to perform other major actions or move further that turn.</li>
                        <li><strong>Requirements:</strong>
                            <ul>
                                <li>Unit must be on an edge.</li>
                                <li>One of the two tiles adjacent to the unit's edge must be Plains or Forest.</li>
                                <li>The chosen tile must not already be fortified by any player.</li>
                            </ul>
                        </li>
                        <li><strong>Process:</strong> The unit moves from the edge to the center of the chosen tile. The tile becomes fortified by that unit's player.</li>
                        <li><strong>Benefits of Fortification:</strong>
                            <ul>
                                <li><strong>Defensive Bonus:</strong> When a fortified unit is attacked, the incoming damage is reduced by 1 (to a minimum of 0 damage).</li>
                                <li><strong>Zone of Control (ZoC):</strong>
                                    <ul>
                                        <li>Immediately upon fortification, deals 1 damage (FORTIFICATION_DAMAGE) to all enemy units on edges adjacent to the newly fortified tile.</li>
                                        <li>At the start of your subsequent turns, deals 1 damage to any enemy units still on edges adjacent to this fortified tile.</li>
                                    </ul>
                                </li>
                                <li><strong>Healing:</strong> At the start of your turn, a fortified unit heals 1 HP if it was not damaged by an enemy attack during the opponent's last turn. (Specifically, if GlobalTurnNumber is at least unit.lastAttackedByHostileOnTurn + 2).</li>
                                <li><strong>Shield:</strong> Healing can increase a unit's HP up to Max HP + 1. This extra point acts as a temporary shield, absorbing one point of damage before normal HP is affected.</li>
                            </ul>
                        </li>
                        <li><strong>Restrictions:</strong> A fortified unit cannot move or perform other actions (except Unfortify or Attack, if an Archer).</li>
                    </ul>
                     <p><strong>3.4 Unfortify Action:</strong></p>
                    <ul>
                        <li>Cost: 1 MP.</li>
                        <li>Ends the unit's ability to perform other major actions or move further that turn.</li>
                        <li><strong>Process:</strong> A fortified unit moves from its tile center to a valid, unoccupied (or occupied by only one other friendly unit) adjacent edge. The tile loses its fortified status.</li>
                    </ul>
                    <p><strong>3.5 Build Bridge Action (Melee Unit Only):</strong></p>
                    <ul>
                        <li>Cost: 1 MP.</li>
                        <li>Ends the unit's ability to perform other major actions or move further that turn.</li>
                        <li><strong>Process:</strong> A Melee unit on an edge can build a bridge on a rotationally adjacent edge that is currently unbridged Water. The new bridge has 5 HP (BRIDGE_MAX_HP).</li>
                    </ul>
                    <p><strong>3.6 End Turn:</strong></p>
                    <ul>
                        <li>Click the "End Turn" button.</li>
                        <li>Control passes to the other player.</li>
                        <li>For the new active player:
                            <ul>
                                <li>All their units regain their full base Movement Points.</li>
                                <li>All their units have their "major action taken" flag reset, allowing them to act again.</li>
                                <li>Zone of Control damage from their fortifications is applied to adjacent enemy units.</li>
                                <li>Healing for their fortified units is processed.</li>
                            </ul>
                        </li>
                        <li>The Global Turn counter increments when Player 2 ends their turn and it becomes Player 1's turn again.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">4. Interacting with the Game <span class="tutorial-arrow">&#9658;</span></div>
                <div class="tutorial-section-content">
                    <ul>
                        <li><strong>Selecting/Deselecting Units:</strong> Click/tap on one of your units to select it. Its information will appear in the left panel, and available actions in the right panel. Click the unit again or an empty space to deselect.</li>
                        <li><strong>Moving Units:</strong>
                            <ul>
                                <li><strong>Drag-and-Drop:</strong> Click/touch and hold on a selected, movable unit, then drag it to a highlighted green valid destination edge and release.</li>
                                <li><strong>Click-to-Move:</strong> With a unit selected, click/tap on a highlighted green valid destination edge.</li>
                            </ul>
                        </li>
                        <li><strong>Performing Actions:</strong>
                            <ul>
                                <li>With a unit selected, click its desired action button in the right panel (e.g., "Attack," "Fortify").</li>
                                <li>Some actions (Fortify, Unfortify, Build Bridge, Attack) will then highlight valid target tiles/edges. Click/tap the desired target to complete the action.</li>
                                <li>To cancel an action selection mode, click the action button again (it will typically say "Cancel...").</li>
                            </ul>
                        </li>
                        <li><strong>Generating a New Map:</strong> Click the "Generate New Map" button. This will reset the current game.</li>
                        <li><strong>Downloading Game:</strong> Click the download icon to save the current game state as a self-contained HTML file.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">5. General Tips <span class="tutorial-arrow">&#9658;</span></div>
                <div class="tutorial-section-content">
                    <ul>
                        <li>Utilize terrain: Forests provide cover but slow movement. Mountains are strong chokepoints but block LOS.</li>
                        <li>Fortifications are key for defense, area denial (ZoC), and unit longevity (healing).</li>
                        <li>Bridges can create new pathways across water, enabling surprise attacks or flanking maneuvers.</li>
                        <li>Protect your Archers, but use their range and LOS to control areas or weaken enemies before Melee units engage.</li>
                        <li>Be mindful of your unit's Movement Points and whether they have already taken a major action.</li>
                    </ul>
                    <p>Good luck, Commander!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW RESPAWN CHOICE MODAL -->
    <div id="respawnModalOverlay" class="modal-overlay">
        <div id="respawnModalContent" class="modal-content">
            <h3>A Unit Has Fallen!</h3>
            <p>Choose a reinforcement to deploy at your base.</p>
            <div id="respawnChoices">
                <button id="respawnMelee" class="respawn-button" data-unit-type="MELEE" title="Melee"></button>
                <button id="respawnArcher" class="respawn-button" data-unit-type="ARCHER" title="Archer"></button>
                <button id="respawnPikeman" class="respawn-button" data-unit-type="PIKEMAN" title="Pikeman"></button>
                <button id="respawnHorseman" class="respawn-button" data-unit-type="HORSEMAN" title="Horseman"></button>
            </div>
        </div>
    </div>


    <script>
        // --- Game Configuration & Constants ---
        const HEX_SIZE = 70; 
        const GRID_RADIUS = 3; 

        // Gameplay Constants
        const RESPAWN_TURN_TIMER = 10;
        const MAX_BASE_CAMP_TURNS = 7;
        const MAX_UNITS_PER_PLAYER = 4;
        const UNIT_CAPS = {
            Melee: 2,
            Archer: 2,
            Pikeman: 2,
            Horseman: 2,
        };
        const FORTIFICATION_DAMAGE = 1; 
        const BRIDGE_MAX_HP = 5;        
        const UNIT_ON_EDGE_OFFSET = HEX_SIZE * 0.2; 
        const ATTACK_COST = 1;          
        const FORTIFY_UNFORTIFY_COST = 1; 
        const BUILD_BRIDGE_COST = 1;    
        const MAX_MOVEMENT_COST = 3;    
        const SHIELD_COLOR = '#30C4C4'; 

        // Visual/Interaction Constants
        const UNIT_DRAW_SIZE_ON_EDGE = HEX_SIZE * 0.25; 
        const FORTIFIED_UNIT_DRAW_SIZE = UNIT_DRAW_SIZE_ON_EDGE * 1.2; 
        const HIGHLIGHT_CLICK_RADIUS = HEX_SIZE * 0.35; 
        const UNIT_CLICK_RADIUS = HEX_SIZE * 0.3;       
        const BRIDGE_CLICK_TOLERANCE = HEX_SIZE * 0.15; 
        const DRAG_SCALE_FACTOR = 1.2;  
        const DRAGGED_DISTANCE_THRESHOLD = 5; 
        const PULSE_DURATION_MS = 2000; 
        const PATH_DRAW_ANIMATION_DURATION_MS = 750; 
        const PATH_DRAW_PAUSE_DURATION_MS = 500; 
        const PATH_DRAW_HOVER_DELAY_MS = 1000; 

        // Map Generation Constants (Updated for Radius 3)
        const MAX_MOUNTAIN_TILES_TOTAL = 8;
        const MAX_WATER_TILES_TOTAL = 12;
        const MAX_FOREST_TILES_TOTAL = 12;
        const MAX_PLAINS_TILES_TOTAL = 18;

        const MAX_MOUNTAIN_TILES_PER_CLUSTER = 3; // Kept the same for cluster density

        const MOUNTAIN_SPAWN_CHANCE = 0.35;
        const WATER_SPAWN_CHANCE = 0.25;
        const FOREST_SPAWN_CHANCE = 0.5;

        const MIN_WATER_TILES_SOFT = 4;
        const MIN_FOREST_TILES_SOFT = 6;
        const MIN_PLAINS_TILES_SOFT = 12;
        const MIN_CENTRAL_PLAINS_SOFT = 3;

        // NEW: Action State Constants
        const ACTION_STATES = {
            IDLE: 'idle',
            UNIT_SELECTED: 'unit_selected',
            SELECTING_FORTIFY_TILE: 'selecting_fortify_tile',
            SELECTING_UNFORTIFY_EDGE: 'selecting_unfortify_edge',
            SELECTING_BRIDGE_EDGE: 'selecting_bridge_edge',
            SELECTING_ATTACK_TARGET: 'selecting_attack_target',
        };

        // Tile Definitions
        const TILE_TYPES = {
            PLAINS:   { name: 'Plains',   color: '#90EE90', baseMoveCost: 1, canFortify: true },
            FOREST:   { name: 'Forest',   color: '#228B22', baseMoveCost: 2, canFortify: true },
            WATER:    { name: 'Water',    color: '#87CEEB', baseMoveCost: Infinity, crossable: false, canFortify: false },
            MOUNTAIN: { name: 'Mountain', color: '#808080', baseMoveCost: 3, canFortify: false, blocksLOS: true } 
        };

        // Unit Definitions
        const UNIT_TYPES = {
            MELEE:    { name: 'Melee',    hp: 12, baseMove: 4, attack: 3, color: '#4040C4', enemyColor: '#C44040', symbol: 'M', canBuildBridge: true,  canFortify: true,  fortificationBonus: 1, attackType: 'melee', defenseNegation: 0, canMoveAfterAttack: false, strengths: ['Archer'],   weaknesses: ['Horseman'] },
            ARCHER:   { name: 'Archer',   hp: 10, baseMove: 3, attack: 3, color: '#4040C4', enemyColor: '#C44040', symbol: 'A', canBuildBridge: false, canFortify: true,  fortificationBonus: 1, attackType: 'ranged', defenseNegation: 0, canMoveAfterAttack: false, strengths: ['Pikeman'],  weaknesses: ['Melee'] },
            PIKEMAN:  { name: 'Pikeman',  hp: 13, baseMove: 3, attack: 3, color: '#4040C4', enemyColor: '#C44040', symbol: 'P', canBuildBridge: false, canFortify: true,  fortificationBonus: 2, attackType: 'melee', defenseNegation: 1, canMoveAfterAttack: false, strengths: ['Horseman'], weaknesses: ['Archer'] },
            HORSEMAN: { name: 'Horseman', hp: 11, baseMove: 5, attack: 3, color: '#4040C4', enemyColor: '#C44040', symbol: 'H', canBuildBridge: false, canFortify: false, fortificationBonus: 0, attackType: 'melee', defenseNegation: 0, canMoveAfterAttack: true,  strengths: ['Melee'],    weaknesses: ['Pikeman'] }
        };

        const UNIT_SVGS = {
            MELEE: `<svg viewBox="170 60 110 280" fill="white">
                        <path d="M 224.613 61.934 L 243.516 108 L 208.709 108.172 L 224.613 61.934 Z"></path>
                        <rect x="210.709" y="108.172" width="31.807" height="192.313"></rect>
                        <rect x="172.161" y="233.27" width="103.853" height="22.254"></rect>
                        <ellipse cx="224.526" cy="312.975" rx="20.582" ry="20.615"></ellipse>
                    </svg>`,
            ARCHER: `<svg viewBox="-10 -18 20 36" fill="white">
                        <path d="M 0 -17.5 L -5 -10 L -1.875 -8.75 L -1.875 5 L -6.25 17.5 L 0 13.75 L 6.25 17.5 L 1.875 5 L 1.875 -8.75 L 5 -10 Z" />
                    </svg>`,
            PIKEMAN: `<svg viewBox="-14 -20 28 40" fill="white">
                        <path d="M -1.35 16.875 L -1.35 1.125 Q -13.5 -3.375 -1.35 -11.25 L 0 -18 L 1.35 -11.25 L 1.35 -7.5 L 8.75 -4.5 L 1.35 -2.25 L 1.35 16.875 Z" />
                    </svg>`,
            HORSEMAN: `<svg viewBox="-12 -16 24 32" fill="white">
                        <path d="M-6 10 L 6 10 L 6 3 L 3 -1 L 9 -3 L 9 -7 L 2 -7 L -2 -12 L -4 -8 L -6 2 Z" />
                    </svg>`
        };

        // Hex Grid Directions (Axial Coordinates)
        const AXIAL_DIRECTIONS = [ { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 }, { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 } ];
        const MAP_DIRECTION_TO_EDGE_INDEX = [0, 5, 4, 3, 2, 1];


        const DEFAULT_MAP_LAYOUT_RADIUS_3 = new Map([
            // q=-3
            ['-3,0', TILE_TYPES.WATER], ['-3,1', TILE_TYPES.WATER], ['-3,2', TILE_TYPES.MOUNTAIN], ['-3,3', TILE_TYPES.MOUNTAIN],
            // q=-2
            ['-2,-1', TILE_TYPES.PLAINS], ['-2,0', TILE_TYPES.PLAINS], ['-2,1', TILE_TYPES.FOREST], ['-2,2', TILE_TYPES.FOREST], ['-2,3', TILE_TYPES.MOUNTAIN],
            // q=-1
            ['-1,-2', TILE_TYPES.PLAINS], ['-1,-1', TILE_TYPES.PLAINS], ['-1,0', TILE_TYPES.PLAINS], ['-1,1', TILE_TYPES.PLAINS], ['-1,2', TILE_TYPES.FOREST], ['-1,3', TILE_TYPES.WATER],
            // q=0
            ['0,-3', TILE_TYPES.WATER], ['0,-2', TILE_TYPES.PLAINS], ['0,-1', TILE_TYPES.PLAINS], ['0,0', TILE_TYPES.FOREST], ['0,1', TILE_TYPES.PLAINS], ['0,2', TILE_TYPES.PLAINS], ['0,3', TILE_TYPES.WATER],
            // q=1
            ['1,-3', TILE_TYPES.WATER], ['1,-2', TILE_TYPES.FOREST], ['1,-1', TILE_TYPES.PLAINS], ['1,0', TILE_TYPES.PLAINS], ['1,1', TILE_TYPES.PLAINS], ['1,2', TILE_TYPES.PLAINS],
            // q=2
            ['2,-3', TILE_TYPES.MOUNTAIN], ['2,-2', TILE_TYPES.FOREST], ['2,-1', TILE_TYPES.FOREST], ['2,0', TILE_TYPES.PLAINS], ['2,1', TILE_TYPES.PLAINS],
            // q=3
            ['3,-3', TILE_TYPES.MOUNTAIN], ['3,-2', TILE_TYPES.MOUNTAIN], ['3,-1', TILE_TYPES.WATER], ['3,0', TILE_TYPES.WATER]
        ]);
        
        const FLAG_HOME_POSITIONS = {
            player1: getEdgeKey(-2, -1, -1, -2), // Edge between P1's base tiles
            player2: getEdgeKey(1, 2, 2, 1)      // Edge between P2's base tiles
        };

        // --- Canvas & UI Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const ui = {
            turnDisplay: document.getElementById('turnDisplay'),
            globalTurnCounterDisplay: document.getElementById('globalTurnCounterDisplay'),
            selectedUnitInfoContainer: document.getElementById('selectedUnitInfoContainer'),
            unitName: document.getElementById('unitName'),
            unitHP: document.getElementById('unitHP'),
            unitMaxHP: document.getElementById('unitMaxHP'),
            unitMovement: document.getElementById('unitMovement'),
            unitPosition: document.getElementById('unitPosition'),
            unitStatus: document.getElementById('unitStatus'),
            actionsPanel: document.getElementById('actionsPanel'),
            fortifyUnfortifyButton: document.getElementById('fortifyUnfortifyButton'),
            buildBridgeButton: document.getElementById('buildBridgeButton'),
            attackButton: document.getElementById('attackButton'),
            endTurnButton: document.getElementById('endTurnButton'),
            generateMapButton: document.getElementById('generateMapButton'),
            downloadButton: document.getElementById('downloadButton'),
            tutorialButton: document.getElementById('tutorialButton'), 
            messageBox: document.getElementById('messageBox'),
            victoryMessage: document.getElementById('victoryMessage'),
            customConfirmModal: document.getElementById('customConfirmModal'),
            customConfirmOkButton: document.getElementById('customConfirmOkButton'),
            customConfirmCancelButton: document.getElementById('customConfirmCancelButton'),
            tutorialModalOverlay: document.getElementById('tutorialModalOverlay'), 
            tutorialCloseButton: document.getElementById('tutorialCloseButton'), 
            tutorialSectionHeaders: document.querySelectorAll('.tutorial-section-header'), 
            actionInfoContainer: document.getElementById('actionInfoContainer'),
            actionLogContent: document.getElementById('actionLogContent'),
        };

        let dragOperationJustConcluded = false;

        // --- Game State ---
        let gameState = {
            tiles: new Map(),
            edges: new Map(),
            units: [],
            currentPlayer: 1,
            globalTurnNumber: 1,
            selectedUnit: null,
            hoveredUnitId: null,
            currentReachableMoves: new Map(),
            gameOver: false,
            gridRadius: GRID_RADIUS,
            actionLog: [], 
            flags: null,
            respawnQueue: { player1: [], player2: [] },
            unitCounts: null,

            // Physical UI states
            isDragging: false,
            draggingUnit: null,
            dragStartX: 0, dragStartY: 0,
            dragUnitRenderX: 0, dragUnitRenderY: 0,
            dragUnitOriginalPosition: null, dragUnitOriginalType: null,
            draggedDistance: 0,
            
            // Logical Game State
            currentActionState: ACTION_STATES.IDLE,

            // Data for actions
            validFortifyTargetTileKeys: [],
            validUnfortifyTargetEdgeKeys: [],
            validBridgeTargetEdgeKeys: [],
            validMeleeAttackTargets: [],
            validArcherAttackTargets: [],
            
            // Debug / Animation data
            potentialDebugPathToDraw: null, 
            debugPathHoverStartTime: null,  
            debugPathToDraw: null,          
            debugPathAnimationStartTime: null,
            debugPathPauseStartTime: null, 
            lastDebugPathKey: null, 
            debugAttackRangeHighlights: [], 
        };

        // --- Utility Functions ---
        function axialToPixel(q, r) {
            const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + canvas.width / 2;
            const y = HEX_SIZE * (3 / 2 * r) + canvas.height / 2;
            return { x, y };
        }

        function pixelToAxial(x, y) {
            const adjX = x - canvas.width / 2; const adjY = y - canvas.height / 2;
            const q_calc = (Math.sqrt(3) / 3 * adjX - 1 / 3 * adjY) / HEX_SIZE;
            const r_calc = (2 / 3 * adjY) / HEX_SIZE;
            return roundAxial({ q: q_calc, r: r_calc });
        }

        function roundAxial({ q, r }) {
            const s = -q - r;
            let rq = Math.round(q); let rr = Math.round(r); let rs = Math.round(s);
            const q_diff = Math.abs(rq - q); const r_diff = Math.abs(rr - r); const s_diff = Math.abs(rs - s);
            if (q_diff > r_diff && q_diff > s_diff) rq = -rr - rs;
            else if (r_diff > s_diff) rr = -rq - rs;
            return { q: rq, r: rr };
        }

        function getTileKey(q, r) { return `${q},${r}`; }

        function getEdgeKey(q1, r1, q2, r2) {
            if (q1 > q2 || (q1 === q2 && r1 > r2)) {
                [q1, q2] = [q2, q1]; [r1, r2] = [r2, r1];
            }
            return `${q1},${r1}_${q2},${r2}`;
        }

        function getEdgeMidpoint(q1, r1, q2, r2) {
            const p1 = axialToPixel(q1, r1); const p2 = axialToPixel(q2, r2);
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }

        function getNeighbors(q, r) { return AXIAL_DIRECTIONS.map(dir => ({ q: q + dir.q, r: r + dir.r })); }

        function axialDistance(q1, r1, q2, r2) {
            const dq = q1 - q2; const dr = r1 - r2; const ds = (-q1 - r1) - (-q2 - r2);
            return (Math.abs(dq) + Math.abs(dr) + Math.abs(ds)) / 2;
        }

        function findDirectionIndex(dir) {
            for (let i = 0; i < AXIAL_DIRECTIONS.length; i++) {
                if (AXIAL_DIRECTIONS[i].q === dir.q && AXIAL_DIRECTIONS[i].r === dir.r) return i;
            }
            return -1;
        }

        function parseEdgeKey(edgeKey) {
            if (!edgeKey || typeof edgeKey !== 'string' || !edgeKey.includes('_')) {
                return [{q:NaN, r:NaN}, {q:NaN, r:NaN}];
            }
            const parts = edgeKey.split('_');
            const [q1, r1] = parts[0].split(',').map(Number);
            const [q2, r2] = parts[1].split(',').map(Number);
            return [{q: q1, r: r1}, {q: q2, r: r2}];
        }

        function clearDebugPath() { 
            gameState.potentialDebugPathToDraw = null;
            gameState.debugPathHoverStartTime = null;
            gameState.debugPathToDraw = null; 
            gameState.debugPathAnimationStartTime = null;
            gameState.debugPathPauseStartTime = null; 
            gameState.lastDebugPathKey = null;
        }

        function resetActionSelectionStates() {
            gameState.currentActionState = gameState.selectedUnit ? ACTION_STATES.UNIT_SELECTED : ACTION_STATES.IDLE;
            
            gameState.validFortifyTargetTileKeys = [];
            gameState.validUnfortifyTargetEdgeKeys = [];
            gameState.validBridgeTargetEdgeKeys = [];
            gameState.validMeleeAttackTargets = [];
            gameState.validArcherAttackTargets = [];
            gameState.debugAttackRangeHighlights = [];
            
            clearDebugPath();
        }

        function distSq(p1, p2) { return (p1.x - p2.x)**2 + (p1.y - p2.y)**2; }
        
        function pointDistance(p1, p2) { return Math.sqrt(distSq(p1,p2)); }


        function distToSegmentSquared(p, v, w) {
            const l2 = distSq(v, w); if (l2 === 0) return distSq(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
            return distSq(p, projection);
        }

        function isLand(tileType) {
            return tileType === TILE_TYPES.PLAINS || tileType === TILE_TYPES.FOREST || tileType === TILE_TYPES.MOUNTAIN;
        }

        function isEdgeAdjacentToSpearWall(unit, edgeKey) {
            if (!unit || !edgeKey) return false;

            const enemyPlayer = unit.player === 1 ? 2 : 1;
            const [h1, h2] = parseEdgeKey(edgeKey);
            if (isNaN(h1.q) || isNaN(h2.q)) return false;

            const adjacentTilesToCheck = new Set();
            adjacentTilesToCheck.add(getTileKey(h1.q, h1.r));
            adjacentTilesToCheck.add(getTileKey(h2.q, h2.r));
            getNeighbors(h1.q, h1.r).forEach(n => adjacentTilesToCheck.add(getTileKey(n.q, n.r)));
            getNeighbors(h2.q, h2.r).forEach(n => adjacentTilesToCheck.add(getTileKey(n.q, n.r)));

            for (const tileKey of adjacentTilesToCheck) {
                const tile = gameState.tiles.get(tileKey);
                if (tile && tile.fortifiedByPlayer === enemyPlayer) {
                    const fortifiedUnit = gameState.units.find(u => u.position === tileKey && u.isFortified);
                    if (fortifiedUnit && fortifiedUnit.type.name === 'Pikeman') {
                        return true; 
                    }
                }
            }
            return false;
        }

        function isRoad(edgeKey) {
            const edge = gameState.edges.get(edgeKey);
            if (!edge) return false;

            const tile1 = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
            const tile2 = gameState.tiles.get(getTileKey(edge.q2, edge.r2));

            if (!tile1 || !tile2) return false;

            // A road cannot be on an edge connected to a water tile.
            return tile1.type !== TILE_TYPES.WATER && tile2.type !== TILE_TYPES.WATER;
        }

        // --- LOS Helper Functions ---
        function getEdgesOfTile(q, r) {
            const edges = new Set(); 
            getNeighbors(q, r).forEach(neighborCoords => {
                if (gameState.tiles.has(getTileKey(neighborCoords.q, neighborCoords.r))) {
                    edges.add(getEdgeKey(q, r, neighborCoords.q, neighborCoords.r));
                }
            });
            return Array.from(edges);
        }

        function isEdgePartOfTile(tileQ, tileR, edgeKey) {
            if (!edgeKey) return false;
            const [h1, h2] = parseEdgeKey(edgeKey);
            return (h1.q === tileQ && h1.r === tileR) || (h2.q === tileQ && h2.r === tileR);
        }

        function isEdgeRotationallyAdjacentToEdgeOnTile(centerTileQ, centerTileR, referenceEdgeKey, targetEdgeKey) {
            if (!isEdgePartOfTile(centerTileQ, centerTileR, referenceEdgeKey) || 
                !isEdgePartOfTile(centerTileQ, centerTileR, targetEdgeKey) ||
                referenceEdgeKey === targetEdgeKey) {
                return false;
            }

            const [ref_h1, ref_h2] = parseEdgeKey(referenceEdgeKey);
            const [tar_h1, tar_h2] = parseEdgeKey(targetEdgeKey);

            let pivotHex, otherHexFromRefEdge, otherHexFromTargetEdge;

            if (ref_h1.q === centerTileQ && ref_h1.r === centerTileR) { pivotHex = ref_h1; otherHexFromRefEdge = ref_h2; }
            else if (ref_h2.q === centerTileQ && ref_h2.r === centerTileR) { pivotHex = ref_h2; otherHexFromRefEdge = ref_h1; }
            else { return false; }
            
            if (tar_h1.q === centerTileQ && tar_h1.r === centerTileR) { otherHexFromTargetEdge = tar_h2; }
            else if (tar_h2.q === centerTileQ && tar_h2.r === centerTileR) { otherHexFromTargetEdge = tar_h1; }
            else { return false; }

            const dirToRefOther = { q: otherHexFromRefEdge.q - pivotHex.q, r: otherHexFromRefEdge.r - pivotHex.r };
            const dirToTargetOther = { q: otherHexFromTargetEdge.q - pivotHex.q, r: otherHexFromTargetEdge.r - pivotHex.r };

            const refDirIdx = findDirectionIndex(dirToRefOther);
            const targetDirIdx = findDirectionIndex(dirToTargetOther);

            if (refDirIdx === -1 || targetDirIdx === -1) return false;

            return (targetDirIdx === (refDirIdx + 1) % 6) || (targetDirIdx === (refDirIdx + 5) % 6);
        }


        // --- Initialization ---
         function initializeGrid(tileLayoutMap = null) {
            canvas.width = (2 * gameState.gridRadius + 1.5) * (HEX_SIZE * Math.sqrt(3));
            canvas.height = (2 * gameState.gridRadius + 1) * (HEX_SIZE * 2 * 0.75) + HEX_SIZE;
            document.querySelectorAll('.ui-panel').forEach(panel => { panel.style.minHeight = canvas.height + 'px'; });

            gameState.tiles.clear(); gameState.edges.clear(); gameState.units = [];
            gameState.gameOver = false; ui.victoryMessage.style.display = 'none';
            ui.endTurnButton.disabled = false;
            gameState.selectedUnit = null; 
            gameState.hoveredUnitId = null; 
            gameState.currentPlayer = 1;
            gameState.globalTurnNumber = 1; 
            updateGlobalTurnDisplay();
            gameState.isDragging = false; 
            gameState.draggingUnit = null; 
            gameState.currentReachableMoves.clear();
            resetActionSelectionStates();
            gameState.actionLog = [];
            gameState.respawnQueue = { player1: [], player2: [] };
            updateActionLogDisplay();
            
            gameState.unitCounts = {
                player1: { Melee: 0, Archer: 0, Pikeman: 0, Horseman: 0 },
                player2: { Melee: 0, Archer: 0, Pikeman: 0, Horseman: 0 }
            };

            // Initialize Flags
            gameState.flags = {
                'p1_flag': {
                    id: 'p1_flag',
                    player: 1,
                    homePosition: FLAG_HOME_POSITIONS.player1,
                    status: 'at_base', 
                    carrierId: null
                },
                'p2_flag': {
                    id: 'p2_flag',
                    player: 2,
                    homePosition: FLAG_HOME_POSITIONS.player2,
                    status: 'at_base',
                    carrierId: null
                }
            };

            if (tileLayoutMap) {
                tileLayoutMap.forEach((type, key) => {
                    const [q, r] = key.split(',').map(Number);
                    gameState.tiles.set(key, { q, r, type, fortifiedByPlayer: null });
                });
            } else {
                if (typeof DEFAULT_MAP_LAYOUT_RADIUS_3 !== 'undefined' && gameState.gridRadius === 3) {
                    DEFAULT_MAP_LAYOUT_RADIUS_3.forEach((type, key) => {
                        const [q, r] = key.split(',').map(Number);
                        gameState.tiles.set(key, { q, r, type, fortifiedByPlayer: null });
                    });
                } else {
                    console.error(`Could not load default map for radius ${gameState.gridRadius}. Generating a blank plains map.`);
                    for (let q = -gameState.gridRadius; q <= gameState.gridRadius; q++) {
                        for (let r = -gameState.gridRadius; r <= gameState.gridRadius; r++) {
                            if (Math.abs(q + r) <= gameState.gridRadius) {
                                const tileKey = getTileKey(q, r);
                                gameState.tiles.set(tileKey, { q, r, type: TILE_TYPES.PLAINS, fortifiedByPlayer: null });
                            }
                        }
                    }
                }
            }

            gameState.tiles.forEach(tile => {
                const {q, r} = tile;
                getNeighbors(q, r).forEach(n_coord => {
                     if (gameState.tiles.has(getTileKey(n_coord.q, n_coord.r))) {
                        const edgeKey = getEdgeKey(q, r, n_coord.q, n_coord.r);
                        if (!gameState.edges.has(edgeKey)) {
                             gameState.edges.set(edgeKey, {
                                q1: q, r1: r, q2: n_coord.q, r2: n_coord.r,
                                units: [], bridge: false, bridgeHp: null, isPathway: true
                            });
                        }
                    }
                });
            });

            if (tileLayoutMap) { placeUnitsOnNewGeneratedMap(); }
            else { 
                gameState.units.push(createUnit(1, UNIT_TYPES.MELEE,    getEdgeKey(1, -2, 0, -2)));
                gameState.units.push(createUnit(1, UNIT_TYPES.ARCHER,   getEdgeKey(-2, 0, -1, -1)));
                gameState.units.push(createUnit(1, UNIT_TYPES.PIKEMAN,  getEdgeKey(-1, -1, 0, -2)));
                gameState.units.push(createUnit(1, UNIT_TYPES.HORSEMAN, getEdgeKey(-2, 0, -2, 1)));
                
                gameState.units.push(createUnit(2, UNIT_TYPES.MELEE,    getEdgeKey(-1, 2, 0, 2)));
                gameState.units.push(createUnit(2, UNIT_TYPES.ARCHER,   getEdgeKey(1, 1, 2, 0)));
                gameState.units.push(createUnit(2, UNIT_TYPES.PIKEMAN,  getEdgeKey(0, 2, 1, 1)));
                gameState.units.push(createUnit(2, UNIT_TYPES.HORSEMAN, getEdgeKey(2, 0, 2, -1)));

                 gameState.units.forEach(unit => {
                    const edge = gameState.edges.get(unit.position);
                    if (edge) edge.units.push(unit);
                    else console.error("Failed to place unit on default edge:", unit.position, unit);
                });
            }

            gameState.units.forEach(unit => {
                unit.currentMove = unit.type.baseMove; unit.hasPerformedMajorAction = false;
            });
            updateTurnDisplay(); 
            updateSelectedUnitInfoPanel(); 
            checkVictoryCondition();
        }

        function createUnit(player, type, edgeKey) {
            const unitId = `unit_${player}_${type.name.toLowerCase()}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
            
            if (gameState.unitCounts) {
                gameState.unitCounts[`player${player}`][type.name]++;
            }

            return {
                id: unitId, player, type, hp: type.hp, maxHp: type.hp,
                currentMove: type.baseMove, positionType: 'edge', position: edgeKey,
                isFortified: false, fortifiedTileKey: null, hasPerformedMajorAction: false,
                isCarryingFlag: false,
                turnsFortifiedAtBase: 0,
                canHeal: true,
                supplyLine: null,
                lastAttackedByHostileOnTurn: 0 
            };
        }

        function spawnUnit(player, unitType) {
            const homeBaseEdgeKey = FLAG_HOME_POSITIONS[`player${player}`];
            let spawnEdgeKey = null;

            const isEdgeValidForSpawn = (edgeKey) => {
                const edge = gameState.edges.get(edgeKey);
                // A valid edge must exist, have less than 2 units, and have NO enemy units.
                // Also ensure it's not the home flag edge itself.
                if (edgeKey === homeBaseEdgeKey) return false;
                return edge && edge.units.length < 2 && !edge.units.some(u => u.player !== player);
            };

            // Search rotationally adjacent edges for a valid spawn point
            const adjacentEdges = getRotationallyAdjacentEdges(homeBaseEdgeKey);
            for (const edgeKey of adjacentEdges) {
                if (isEdgeValidForSpawn(edgeKey)) {
                    spawnEdgeKey = edgeKey;
                    break; 
                }
            }

            if (spawnEdgeKey) {
                const newUnit = createUnit(player, unitType, spawnEdgeKey);
                gameState.units.push(newUnit);
                const edge = gameState.edges.get(spawnEdgeKey);
                edge.units.push(newUnit);
                logAction(`P${player} ${unitType.name} has returned to the fight!`, player);
                return true;
            }
            
            logAction(`P${player} Base is blocked! Cannot respawn ${unitType.name}.`, player);
            return false;
        }

        // --- Drawing Functions ---
         function drawHexFill(q, r, fillColor) {
            const { x, y } = axialToPixel(q, r); ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 180 * (60 * i - 30);
                const vx = x + HEX_SIZE * Math.cos(angle); const vy = y + HEX_SIZE * Math.sin(angle);
                if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
            }
            ctx.closePath(); ctx.fillStyle = fillColor; ctx.fill();
        }

        function drawHexEdgesAndBoundaries() {
            const edgeLineWidth = 2;
            gameState.edges.forEach(edge => {
                const tileA = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
                const tileB = gameState.tiles.get(getTileKey(edge.q2, edge.r2));
                if (!tileA || !tileB) return;
                const typeA = tileA.type; const typeB = tileB.type; let edgeStrokeColor;
                const landEdgeColor = '#A0522D'; const beachEdgeColor = '#F0E68C'; const waterEdgeColor = '#4682B4';
                if (isLand(typeA) && isLand(typeB)) edgeStrokeColor = landEdgeColor;
                else if ((isLand(typeA) && typeB === TILE_TYPES.WATER) || (typeA === TILE_TYPES.WATER && isLand(typeB))) edgeStrokeColor = beachEdgeColor;
                else if (typeA === TILE_TYPES.WATER && typeB === TILE_TYPES.WATER) edgeStrokeColor = waterEdgeColor;
                else edgeStrokeColor = '#1a252f';

                const p1_center = axialToPixel(edge.q1, edge.r1); const p2_center = axialToPixel(edge.q2, edge.r2);
                const edgeMidX = (p1_center.x + p2_center.x) / 2; const edgeMidY = (p1_center.y + p2_center.y) / 2;
                const dx_centers = p2_center.x - p1_center.x; const dy_centers = p2_center.y - p1_center.y;
                let perp_dx = -dy_centers; let perp_dy = dx_centers;
                const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
                if (len_perp_vec === 0) return;
                perp_dx = (perp_dx / len_perp_vec) * (HEX_SIZE / 2); perp_dy = (perp_dy / len_perp_vec) * (HEX_SIZE / 2);
                ctx.beginPath(); ctx.moveTo(edgeMidX + perp_dx, edgeMidY + perp_dy); ctx.lineTo(edgeMidX - perp_dx, edgeMidY - perp_dy);
                ctx.strokeStyle = edgeStrokeColor; ctx.lineWidth = edgeLineWidth; ctx.stroke();
            });

             const boundaryEdgeColor = '#000000';
             gameState.tiles.forEach(tile => {
                 const {q, r} = tile; const {x: centerX, y: centerY} = axialToPixel(q,r);
                 for (let directionIndex = 0; directionIndex < 6; directionIndex++) {
                     const neighborDir = AXIAL_DIRECTIONS[directionIndex];
                     const neighborQ = q + neighborDir.q; const neighborR = r + neighborDir.r;
                     if (!gameState.tiles.has(getTileKey(neighborQ, neighborR))) {
                         const edgeIndexOfCurrentHex = MAP_DIRECTION_TO_EDGE_INDEX[directionIndex];
                         const v1_idx = edgeIndexOfCurrentHex; const v2_idx = (edgeIndexOfCurrentHex + 1) % 6;
                         const vert1_angle = Math.PI / 180 * (60 * v1_idx - 30);
                         const edge_v1_x = centerX + HEX_SIZE * Math.cos(vert1_angle); const edge_v1_y = centerY + HEX_SIZE * Math.sin(vert1_angle);
                         const vert2_angle = Math.PI / 180 * (60 * v2_idx - 30);
                         const edge_v2_x = centerX + HEX_SIZE * Math.cos(vert2_angle); const edge_v2_y = centerY + HEX_SIZE * Math.sin(vert2_angle);
                         ctx.beginPath(); ctx.moveTo(edge_v1_x, edge_v1_y); ctx.lineTo(edge_v2_x, edge_v2_y);
                         ctx.strokeStyle = boundaryEdgeColor; ctx.lineWidth = edgeLineWidth; ctx.stroke();
                     }
                 }
             });
        }

        function drawUnitHealthBar(ctx, unitX, unitY, ringOuterRadius, ringThickness, currentHp, maxHp) {
            if (maxHp <= 0) return;
            
            const displayHpPercentage = Math.max(0, Math.min(1, currentHp / maxHp)); 
            const isShielded = currentHp > maxHp;

            const startAngle = -Math.PI / 2; 
            const fullAngle = 2 * Math.PI;
            const healthRingCenterlineRadius = ringOuterRadius - (ringThickness / 2);
            
            const originalLineWidth = ctx.lineWidth; 
            const originalLineCap = ctx.lineCap;
            ctx.lineWidth = ringThickness; 
            ctx.lineCap = 'butt';

            if (displayHpPercentage < 1) {
                ctx.beginPath(); 
                ctx.strokeStyle = '#4A4A4A'; 
                const healthEndAngle = startAngle + displayHpPercentage * fullAngle;
                ctx.arc(unitX, unitY, healthRingCenterlineRadius, healthEndAngle, startAngle + fullAngle, false);
                ctx.stroke();
            }

            if (displayHpPercentage > 0) {
                ctx.beginPath(); 
                ctx.strokeStyle = isShielded ? SHIELD_COLOR : '#32CD32'; 
                const currentHealthEndAngle = startAngle + displayHpPercentage * fullAngle;
                ctx.arc(unitX, unitY, healthRingCenterlineRadius, startAngle, currentHealthEndAngle, false);
                ctx.stroke();
            }
            
            ctx.lineWidth = originalLineWidth; 
            ctx.lineCap = originalLineCap;
        }


        function drawFortificationOutlines() {
            const fortifiedTilesP1 = new Set();
            const fortifiedTilesP2 = new Set();

            gameState.tiles.forEach((tile, key) => {
                if (tile.fortifiedByPlayer === 1) {
                    fortifiedTilesP1.add(key);
                } else if (tile.fortifiedByPlayer === 2) {
                    fortifiedTilesP2.add(key);
                }
            });

            const p1BaseEdgeKey = FLAG_HOME_POSITIONS.player1;
            const [p1_h1, p1_h2] = parseEdgeKey(p1BaseEdgeKey);
            const p1BaseTileKeys = [getTileKey(p1_h1.q, p1_h1.r), getTileKey(p1_h2.q, p1_h2.r)];
            p1BaseTileKeys.forEach(key => fortifiedTilesP1.add(key));


            const p2BaseEdgeKey = FLAG_HOME_POSITIONS.player2;
            const [p2_h1, p2_h2] = parseEdgeKey(p2BaseEdgeKey);
            const p2BaseTileKeys = [getTileKey(p2_h1.q, p2_h1.r), getTileKey(p2_h2.q, p2_h2.r)];
            p2BaseTileKeys.forEach(key => fortifiedTilesP2.add(key));


            const drawBordersForPlayer = (tileSet, color) => {
                tileSet.forEach(tileKey => {
                    const tile = gameState.tiles.get(tileKey);
                    if (!tile) return;

                    const { x: centerX, y: centerY } = axialToPixel(tile.q, tile.r);

                    for (let i = 0; i < 6; i++) {
                        const neighborDir = AXIAL_DIRECTIONS[i];
                        const neighborQ = tile.q + neighborDir.q;
                        const neighborR = tile.r + neighborDir.r;
                        const neighborKey = getTileKey(neighborQ, neighborR);

                        // Only draw the edge if the neighbor is not in the same player's fortified set.
                        if (!tileSet.has(neighborKey)) {
                             // FIX: Use the mapping constant to get the correct edge index for drawing
                             const v1_idx = MAP_DIRECTION_TO_EDGE_INDEX[i];
                             const v2_idx = (v1_idx + 1) % 6;
                             
                             const vert1_angle = Math.PI / 180 * (60 * v1_idx - 30);
                             const edge_v1_x = centerX + HEX_SIZE * Math.cos(vert1_angle);
                             const edge_v1_y = centerY + HEX_SIZE * Math.sin(vert1_angle);

                             const vert2_angle = Math.PI / 180 * (60 * v2_idx - 30);
                             const edge_v2_x = centerX + HEX_SIZE * Math.cos(vert2_angle);
                             const edge_v2_y = centerY + HEX_SIZE * Math.sin(vert2_angle);
                             
                             ctx.beginPath();
                             ctx.moveTo(edge_v1_x, edge_v1_y);
                             ctx.lineTo(edge_v2_x, edge_v2_y);
                             ctx.strokeStyle = color;
                             ctx.lineWidth = 5;
                             ctx.stroke();
                        }
                    }
                });
            };

            drawBordersForPlayer(fortifiedTilesP1, UNIT_TYPES.MELEE.color);
            drawBordersForPlayer(fortifiedTilesP2, UNIT_TYPES.MELEE.enemyColor);
        }

        function drawContestedEdgeIndicator() {
            const CONTESTED_EDGE_COLOR = '#C440C4';

            gameState.edges.forEach(edge => {
                if (edge.units.length < 2) return;

                const playerOnEdge = edge.units[0].player;
                const allUnitsSamePlayer = edge.units.every(u => u.player === playerOnEdge);
                if (!allUnitsSamePlayer) return;

                const hasArcher = edge.units.some(u => u.type.name === 'Archer');
                const hasMelee = edge.units.some(u => u.type.name === 'Melee');
                
                if (!hasArcher || !hasMelee) return;

                const opponentPlayer = playerOnEdge === 1 ? 2 : 1;
                const tile1 = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
                const tile2 = gameState.tiles.get(getTileKey(edge.q2, edge.r2));
                const isContested = (tile1 && tile1.fortifiedByPlayer === opponentPlayer) || 
                                  (tile2 && tile2.fortifiedByPlayer === opponentPlayer);

                if (isContested) {
                    const p1_center = axialToPixel(edge.q1, edge.r1);
                    const p2_center = axialToPixel(edge.q2, edge.r2);
                    const edgeMidX = (p1_center.x + p2_center.x) / 2;
                    const edgeMidY = (p1_center.y + p2_center.y) / 2;

                    let perp_dx = -(p2_center.y - p1_center.y);
                    let perp_dy = p2_center.x - p1_center.x;
                    const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);

                    if (len_perp_vec > 0) {
                        const scale = HEX_SIZE / 2;
                        perp_dx = (perp_dx / len_perp_vec) * scale;
                        perp_dy = (perp_dy / len_perp_vec) * scale;
                        
                        const startX = edgeMidX + perp_dx;
                        const startY = edgeMidY + perp_dy;
                        const endX = edgeMidX - perp_dx;
                        const endY = edgeMidY - perp_dy;

                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.strokeStyle = CONTESTED_EDGE_COLOR;
                        ctx.lineWidth = 5;
                        ctx.stroke();
                    }
                }
            });
        }


        function drawActionSelectionHighlights(targetKeys, type) {
            if (!targetKeys || targetKeys.length === 0) return;
            let fillColor, strokeColor;
            switch(type) {
                case 'fortify':
                    fillColor = 'rgba(255, 255, 0, 0.3)'; strokeColor = '#FFD700';
                    targetKeys.forEach(tileKey => {
                        const tile = gameState.tiles.get(tileKey);
                        if (tile) {
                           const { x, y } = axialToPixel(tile.q, tile.r); ctx.beginPath();
                           for (let i = 0; i < 6; i++) {
                               const angle = Math.PI / 180 * (60 * i - 30);
                               const vx = x + HEX_SIZE * Math.cos(angle); const vy = y + HEX_SIZE * Math.sin(angle);
                               if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                           }
                           ctx.closePath(); ctx.fillStyle = fillColor; ctx.fill();
                           ctx.strokeStyle = strokeColor; ctx.lineWidth = 3; ctx.stroke();
                        }
                    });
                    break;
                case 'unfortify': case 'bridge':
                    fillColor = type === 'unfortify' ? 'rgba(0, 150, 255, 0.4)' : 'rgba(139, 69, 19, 0.4)';
                    strokeColor = type === 'unfortify' ? '#007ACC' : '#8B4513';
                    targetKeys.forEach(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        if (edge) {
                            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                            ctx.beginPath(); ctx.arc(mid.x, mid.y, HEX_SIZE * 0.25, 0, 2 * Math.PI);
                            ctx.fillStyle = fillColor; ctx.fill();
                            ctx.strokeStyle = strokeColor; ctx.lineWidth = 2; ctx.stroke();
                        }
                    });
                    break;
            }
        }

        function drawBridge(edge, color = '#8B4513', outlineColor = null, outlineWidth = 0) {
            const p1_center = axialToPixel(edge.q1, edge.r1); const p2_center = axialToPixel(edge.q2, edge.r2);
            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
            const angle = Math.atan2(p2_center.y - p1_center.y, p2_center.x - p1_center.x);
            const bridgeLengthAcross = HEX_SIZE * 0.9; const bridgeThicknessAlong = HEX_SIZE * 0.15;
            ctx.save(); ctx.translate(mid.x, mid.y); ctx.rotate(angle + Math.PI / 2);
            ctx.fillStyle = color;
            ctx.fillRect(-bridgeLengthAcross / 2, -bridgeThicknessAlong / 2, bridgeLengthAcross, bridgeThicknessAlong);
            if (outlineColor && outlineWidth > 0) {
                ctx.strokeStyle = outlineColor; ctx.lineWidth = outlineWidth;
                ctx.strokeRect(-bridgeLengthAcross / 2, -bridgeThicknessAlong / 2, bridgeLengthAcross, bridgeThicknessAlong);
            }
            ctx.restore();
        }

        function drawBridges() { gameState.edges.forEach(edge => { if (edge.bridge) drawBridge(edge); }); }

        function drawBridgeAttackHighlightsOnly(targetsToHighlight) {
            if (!targetsToHighlight || targetsToHighlight.length === 0) return;
            targetsToHighlight.forEach(targetInfo => {
                if (targetInfo.isBridgeTarget && targetInfo.edgeKey) {
                    const edge = gameState.edges.get(targetInfo.edgeKey);
                    if (edge && edge.bridge) drawBridge(edge, 'rgba(139, 69, 19, 0.5)', 'rgba(255, 0, 0, 0.9)', 3);
                }
            });
        }

        function drawFlags() {
            if (!gameState.flags) return;

            Object.values(gameState.flags).forEach(flag => {
                if (flag.status === 'at_base') {
                    const edge = gameState.edges.get(flag.homePosition);
                    if (!edge) return;
                    
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    const teamColor = flag.player === 1 ? '#5dade2' : '#e74c3c';
                    const flagIconColor = '#ecf0f1'; 
                    const flagPoleColor = '#2c3e50';
                    const circleRadius = HEX_SIZE * 0.18;
                    const flagSize = circleRadius * 1.2; 

                    ctx.save();
                    ctx.translate(mid.x, mid.y);

                    ctx.beginPath();
                    ctx.arc(0, 0, circleRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = teamColor; 
                    ctx.fill();

                    ctx.strokeStyle = '#1a252f';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-3, flagSize * 0.5);
                    ctx.lineTo(-3, -flagSize * 0.5);
                    ctx.strokeStyle = flagPoleColor;
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-2, -flagSize * 0.5);
                    ctx.lineTo(flagSize * 0.45, -flagSize * 0.3);
                    ctx.lineTo(-2, -flagSize * 0);
                    ctx.closePath();
                    ctx.fillStyle = flagIconColor; 
                    ctx.fill(); 
                    
                    ctx.restore();
                }
            });
        }

        function drawSupplyLines() {
            const currentTime = Date.now();
            
            gameState.units.forEach(unit => {
                if (unit.isFortified && unit.supplyLine && unit.supplyLine.path) {
                    const path = unit.supplyLine.path;
                    if (path.length === 0) return;

                    // Check for interception to determine color
                    const isIntercepted = path.some(edgeKey => {
                    const edge = gameState.edges.get(edgeKey);
                    if (!edge) return false;
                    // An edge is intercepted if it has an enemy unit that is NOT currently being dragged.
                    return edge.units.some(u => u.player !== unit.player && (!gameState.isDragging || u.id !== gameState.draggingUnit.id));
                });

                    // Set line style based on status
                    let lineColor, lineWidth, isDashed;
                    if (isIntercepted) {
                        lineColor = '#f39c12'; // Bright orange for broken supply
                        lineWidth = 4;
                        isDashed = true;
                    } else {
                        lineColor = unit.player === 1 ? 'rgba(91, 148, 255, 0.8)' : 'rgba(255, 99, 132, 0.8)';
                        // Create a pulse effect for the line width
                        const pulse = (Math.sin(currentTime / 300) + 1) / 2; // Varies between 0 and 1
                        lineWidth = 2 + pulse * 3; // Varies between 2 and 5
                        isDashed = false;
                    }

                    ctx.save();
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = lineWidth;
                    ctx.lineCap = 'round';
                    if (isDashed) {
                        ctx.setLineDash([15, 10]);
                    }

                    // Draw the supply line along the edges
                    path.forEach(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        if(edge) {
                            const p1_center = axialToPixel(edge.q1, edge.r1);
                            const p2_center = axialToPixel(edge.q2, edge.r2);
                            const edgeMidX = (p1_center.x + p2_center.x) / 2;
                            const edgeMidY = (p1_center.y + p2_center.y) / 2;
                            
                            let perp_dx = -(p2_center.y - p1_center.y);
                            let perp_dy = p2_center.x - p1_center.x;
                            const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
                            
                            if (len_perp_vec > 0) {
                                const scale = HEX_SIZE / 2;
                                perp_dx = (perp_dx / len_perp_vec) * scale;
                                perp_dy = (perp_dy / len_perp_vec) * scale;

                                ctx.beginPath();
                                ctx.moveTo(edgeMidX + perp_dx, edgeMidY + perp_dy);
                                ctx.lineTo(edgeMidX - perp_dx, edgeMidY - perp_dy);
                                ctx.stroke();
                            }
                        }
                    });
                    
                    ctx.restore();
                }
            });
        }

        function drawUnitAttackHighlightsOnly(targetsToHighlight) {
            if (!targetsToHighlight || targetsToHighlight.length === 0) return;
            targetsToHighlight.forEach(targetInfo => {
                if (!targetInfo.isBridgeTarget && targetInfo.unit) {
                    const targetUnit = targetInfo.unit; let unitX, unitY;
                    const unitSizeToHighlight = HEX_SIZE * 0.3;
                    if (targetUnit.isFortified && targetUnit.positionType === 'center' && targetInfo.tileKeyForTarget) {
                        const tile = gameState.tiles.get(targetInfo.tileKeyForTarget);
                        if (tile) { const centerPixel = axialToPixel(tile.q, tile.r); unitX = centerPixel.x; unitY = centerPixel.y; }
                        else return;
                    } else if (targetInfo.edgeKey) {
                        const edge = gameState.edges.get(targetInfo.edgeKey); if (!edge) return;
                        const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2); unitX = mid.x; unitY = mid.y;
                        const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                        const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === targetUnit.id);
                        if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                            const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                            const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                            let dx = p2.x - p1.x, dy = p2.y - p1.y; const len = Math.sqrt(dx*dx + dy*dy) || 1;
                            let perpX = -dy / len, perpY = dx / len;
                            unitX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                            unitY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                        }
                    } else return;
                    ctx.beginPath(); ctx.arc(unitX, unitY, unitSizeToHighlight, 0, 2 * Math.PI);
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; ctx.lineWidth = 3; ctx.stroke();
                }
            });
        }

        function drawSword(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 0.75; 
            ctx.strokeStyle = symbolColor;
            ctx.fillStyle = symbolColor;
            ctx.lineWidth = Math.max(1.5, symbolDisplayRadius * 0.08);
            ctx.lineJoin = 'round';
            const pommelRadius = scale * 0.15;
            const pommelY = centerY + scale * 0.55;
            ctx.beginPath();
            ctx.arc(centerX, pommelY, pommelRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.lineCap = 'round';
            const guardWidth = scale * 0.75;
            const guardY = centerY + scale * 0.2;
            const guardThickness = scale * 0.15;
            ctx.beginPath();
            ctx.moveTo(centerX - guardWidth / 2, guardY);
            ctx.lineTo(centerX + guardWidth / 2, guardY);
            const oldWidth = ctx.lineWidth;
            ctx.lineWidth = guardThickness;
            ctx.stroke();
            ctx.lineWidth = oldWidth;
            ctx.lineCap = 'butt';
            const bladeWidth = scale * 0.22;
            const bladeHeight = scale * 0.9;
            const bladeY = guardY - bladeHeight;
            ctx.beginPath();
            ctx.rect(centerX - bladeWidth / 2, bladeY, bladeWidth, bladeHeight);
            ctx.fill();
            const tipBaseY = bladeY;
            const tipHeight = scale * 0.35;
            const tipTopY = tipBaseY - tipHeight;
            const tipWidth = bladeWidth * 1.1;
            ctx.beginPath();
            ctx.moveTo(centerX, tipTopY); 
            ctx.lineTo(centerX - tipWidth / 2, tipBaseY); 
            ctx.lineTo(centerX + tipWidth / 2, tipBaseY); 
            ctx.closePath();
            ctx.fill();
        }

        function drawArrow(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 1.0; 
            ctx.fillStyle = symbolColor;
            ctx.strokeStyle = symbolColor; 
            ctx.lineWidth = Math.max(1.0, symbolDisplayRadius * 0.05);
            ctx.lineJoin = 'round';
            ctx.beginPath();
            const tipY = centerY - scale * 0.7;
            ctx.moveTo(centerX, tipY);
            const headBaseY = centerY - scale * 0.4;
            const headWidth = scale * 0.4;
            ctx.lineTo(centerX - headWidth / 2, headBaseY); 
            const shaftWidth = scale * 0.15;
            const shaftTopY = centerY - scale * 0.35;
            ctx.lineTo(centerX - shaftWidth / 2, headBaseY);
            ctx.lineTo(centerX - shaftWidth / 2, shaftTopY);
            const fletchTopY = centerY + scale * 0.2;
            const fletchBottomY = centerY + scale * 0.7;
            const fletchWidth = scale * 0.5;
            ctx.lineTo(centerX - shaftWidth / 2, fletchTopY); 
            ctx.lineTo(centerX - fletchWidth / 2, fletchBottomY); 
            ctx.lineTo(centerX, centerY + scale * 0.55); 
            ctx.lineTo(centerX + fletchWidth / 2, fletchBottomY); 
            ctx.lineTo(centerX + shaftWidth / 2, fletchTopY);
            ctx.lineTo(centerX + shaftWidth / 2, shaftTopY);
            ctx.lineTo(centerX + shaftWidth / 2, headBaseY);
            ctx.lineTo(centerX + headWidth / 2, headBaseY);
            ctx.closePath();
            ctx.fill();
        }

        function drawPikemanSymbol(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 0.9; 
            ctx.strokeStyle = symbolColor;
            ctx.fillStyle = symbolColor;
            ctx.lineWidth = Math.max(1.0, symbolDisplayRadius * 0.05);
            ctx.lineJoin = 'round';
            ctx.beginPath();
            const shaftWidth = scale * 0.12;
            const shaftBottomY = centerY + scale * 0.75;
            ctx.moveTo(centerX - shaftWidth / 2, shaftBottomY);
            const axeBottomY = centerY + scale * 0.05;
            ctx.lineTo(centerX - shaftWidth / 2, axeBottomY);
            const axeTopY = centerY - scale * 0.35;
            ctx.quadraticCurveTo(
                centerX - scale * 0.6, 
                centerY - scale * 0.15,
                centerX - shaftWidth / 2, axeTopY 
            );
            const spearBaseY = centerY - scale * 0.5;
            ctx.lineTo(centerX - shaftWidth / 2, spearBaseY);
            const spearTipY = centerY - scale * 0.8;
            ctx.lineTo(centerX, spearTipY); 
            ctx.lineTo(centerX + shaftWidth / 2, spearBaseY); 
            const spikeTopY = centerY - scale * 0.3;
            ctx.lineTo(centerX + shaftWidth / 2, spikeTopY);
            const spikePointX = centerX + scale * 0.35;
            const spikeMidY = centerY - scale * 0.2;
            const spikeBottomY = centerY - scale * 0.1;
            ctx.lineTo(spikePointX, spikeMidY); 
            ctx.lineTo(centerX + shaftWidth / 2, spikeBottomY); 
            ctx.lineTo(centerX + shaftWidth / 2, shaftBottomY);
            ctx.closePath();
            ctx.fill();
        }

        function drawHorsemanSymbol(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 1.0;
            ctx.fillStyle = symbolColor;
            ctx.beginPath();
            ctx.moveTo(centerX - scale * 0.3, centerY + scale * 0.5);
            ctx.lineTo(centerX + scale * 0.3, centerY + scale * 0.5);
            ctx.lineTo(centerX + scale * 0.3, centerY + scale * 0.15);
            ctx.lineTo(centerX + scale * 0.15, centerY - scale * 0.05);
            ctx.lineTo(centerX + scale * 0.45, centerY - scale * 0.15);
            ctx.lineTo(centerX + scale * 0.45, centerY - scale * 0.35);
            ctx.lineTo(centerX + scale * 0.1, centerY - scale * 0.35);
            ctx.lineTo(centerX - scale * 0.1, centerY - scale * 0.6);
            ctx.lineTo(centerX - scale * 0.2, centerY - scale * 0.4);
            ctx.lineTo(centerX - scale * 0.3, centerY + scale * 0.1);
            ctx.closePath();
            ctx.fill();
        }

        function drawUnitSymbol(ctx, unit, x, y, radius, symbolColor) {
            const symbolDisplaySize = Math.max(1, radius);
            if (unit.type.symbol === 'M') {
                drawSword(ctx, x, y, symbolDisplaySize, symbolColor);
            } else if (unit.type.symbol === 'A') {
                drawArrow(ctx, x, y, symbolDisplaySize, symbolColor);
            } else if (unit.type.symbol === 'P') {
                drawPikemanSymbol(ctx, x, y, symbolDisplaySize, symbolColor);
            } else if (unit.type.symbol === 'H') {
                drawHorsemanSymbol(ctx, x, y, symbolDisplaySize, symbolColor);
            } else { 
                ctx.fillStyle = symbolColor;
                ctx.font = `bold ${symbolDisplaySize * 1.5}px 'Exo 2'`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(unit.type.symbol, x, y);
            }
        }

        function drawSingleUnit(ctx, unit, x, y, radius) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = unit.player === 1 ? unit.type.color : unit.type.enemyColor;
            ctx.fill();
            
            const healthBarVisualThickness = radius * 0.3;
            drawUnitHealthBar(ctx, x, y, radius, healthBarVisualThickness, unit.hp, unit.maxHp);
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            
            let mainBorderColor;
            let mainBorderWidth = 3;

            if (unit.isCarryingFlag) {
                const enemyPlayer = unit.player === 1 ? 2 : 1;
                mainBorderColor = enemyPlayer === 1 ? UNIT_TYPES.MELEE.color : UNIT_TYPES.MELEE.enemyColor;
            } else if (gameState.selectedUnit && gameState.selectedUnit.id === unit.id) {
                mainBorderColor = '#FFD700';
            } else if (gameState.hoveredUnitId === unit.id && unit.player === gameState.currentPlayer) {
                mainBorderColor = '#ADD8E6'; 
                mainBorderWidth = 2.5;
            } else {
                mainBorderColor = unit.isFortified ? '#FFF' : '#000';
                mainBorderWidth = unit.isFortified ? 2 : 1.5;
            }
            
            ctx.strokeStyle = mainBorderColor;
            ctx.lineWidth = mainBorderWidth;
            ctx.stroke();

            const symbolColor = unit.isFortified ? '#000' : '#FFF';
            const radiusForSymbol = radius - healthBarVisualThickness;
            drawUnitSymbol(ctx, unit, x, y, radiusForSymbol, symbolColor);
        }

        function drawUnits() {
            const offsetDistance = UNIT_ON_EDGE_OFFSET;

            gameState.edges.forEach((edge) => {
                const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge' && (!gameState.isDragging || u.id !== gameState.draggingUnit.id));
                if (edgeUnitsOnly.length > 0) {
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    const p1_hex_center = axialToPixel(edge.q1, edge.r1); const p2_hex_center = axialToPixel(edge.q2, edge.r2);
                    let dx_centers = p2_hex_center.x - p1_hex_center.x; let dy_centers = p2_hex_center.y - p1_hex_center.y;
                    const len_centers = Math.sqrt(dx_centers*dx_centers + dy_centers*dy_centers) || 1;
                    let perpX = -dy_centers / len_centers; let perpY = dx_centers / len_centers;
                    
                    edgeUnitsOnly.forEach((unit, index) => {
                        let unitX = mid.x, unitY = mid.y;
                        if (edgeUnitsOnly.length > 1) {
                            const offsetSign = (index % 2 === 0) ? -1 : 1;
                            unitX += perpX * offsetDistance * offsetSign * (0.5); 
                            unitY += perpY * offsetDistance * offsetSign * (0.5);
                        }
                        drawSingleUnit(ctx, unit, unitX, unitY, UNIT_DRAW_SIZE_ON_EDGE);
                    });
                }
            });

            gameState.units.forEach(unit => {
                if (unit.isFortified && unit.positionType === 'center' && (!gameState.isDragging || unit.id !== gameState.draggingUnit.id)) {
                    const tile = gameState.tiles.get(unit.position);
                    if (tile) {
                        const {x, y} = axialToPixel(tile.q, tile.r);
                        drawSingleUnit(ctx, unit, x, y, FORTIFIED_UNIT_DRAW_SIZE);
                    }
                }
            });

            if (gameState.isDragging && gameState.draggingUnit) {
                const unit = gameState.draggingUnit;
                const unitX = gameState.dragUnitRenderX;
                const unitY = gameState.dragUnitRenderY;
                const radius = (unit.isFortified ? FORTIFIED_UNIT_DRAW_SIZE : UNIT_DRAW_SIZE_ON_EDGE) * DRAG_SCALE_FACTOR;
                drawSingleUnit(ctx, unit, unitX, unitY, radius);
            }
        }


        function drawMovementHighlights() {
            const unitForHighlights = gameState.isDragging ? gameState.draggingUnit : gameState.selectedUnit;

            const isActionSelectionActive = gameState.currentActionState !== ACTION_STATES.IDLE && 
                                            gameState.currentActionState !== ACTION_STATES.UNIT_SELECTED;

            if (!unitForHighlights || unitForHighlights.isFortified || (!gameState.isDragging && isActionSelectionActive)) {
                return;
            }
            
            if (!gameState.isDragging) {
                if (unitForHighlights.currentMove < 1) return;
                if (unitForHighlights.hasPerformedMajorAction && !unitForHighlights.type.canMoveAfterAttack) {
                    return;
                }
            }

            gameState.currentReachableMoves.forEach((data, edgeKey) => {
                if (!gameState.isDragging && edgeKey === unitForHighlights.position) return;
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    ctx.beginPath(); ctx.arc(mid.x, mid.y, HEX_SIZE * 0.2, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)'; ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 100, 0, 0.6)'; ctx.lineWidth = 2; ctx.stroke();
                }
            });
        }

        function drawDebugPath() {
            const currentTime = Date.now();

            if (gameState.potentialDebugPathToDraw && gameState.debugPathHoverStartTime !== null) {
                if (currentTime - gameState.debugPathHoverStartTime >= PATH_DRAW_HOVER_DELAY_MS) {
                    if (gameState.debugPathToDraw !== gameState.potentialDebugPathToDraw) {
                        gameState.debugPathToDraw = gameState.potentialDebugPathToDraw;
                        gameState.debugPathAnimationStartTime = currentTime; 
                        gameState.debugPathPauseStartTime = null;
                        gameState.lastDebugPathKey = gameState.debugPathToDraw ? gameState.debugPathToDraw.join('-') : null;
                    }
                }
            } else if (!gameState.potentialDebugPathToDraw && gameState.debugPathToDraw !== null) {
                gameState.debugPathToDraw = null;
                gameState.debugPathAnimationStartTime = null;
                gameState.debugPathPauseStartTime = null;
                gameState.lastDebugPathKey = null;
            }

            const pathEdgeKeysArray = gameState.debugPathToDraw;
            if (!pathEdgeKeysArray || pathEdgeKeysArray.length < 2) {
                return; 
            }
            
            let progress = 0;
            if (gameState.debugPathPauseStartTime !== null) { 
                if (currentTime - gameState.debugPathPauseStartTime >= PATH_DRAW_PAUSE_DURATION_MS) {
                    gameState.debugPathAnimationStartTime = currentTime; 
                    gameState.debugPathPauseStartTime = null;
                    progress = 0; 
                } else {
                    progress = 1.0; 
                }
            } else if (gameState.debugPathAnimationStartTime !== null) { 
                const elapsedTime = currentTime - gameState.debugPathAnimationStartTime;
                progress = elapsedTime / PATH_DRAW_ANIMATION_DURATION_MS;

                if (progress >= 1.0) {
                    progress = 1.0;
                    if (gameState.lastDebugPathKey === pathEdgeKeysArray.join('-')) {
                        gameState.debugPathPauseStartTime = currentTime; 
                    }
                }
            } else {
                return; 
            }
            
            progress = Math.min(1, progress); 


            ctx.save();
            ctx.strokeStyle = '#E6C410'; 
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const points = pathEdgeKeysArray.map(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (!edge) return null;
                return getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
            }).filter(p => p !== null);

            if (points.length < 2) { ctx.restore(); return; }

            let totalPathLength = 0;
            for (let i = 0; i < points.length - 1; i++) {
                totalPathLength += pointDistance(points[i], points[i+1]);
            }
            if (totalPathLength === 0) { ctx.restore(); return; }

            const drawableLength = totalPathLength * progress;
            let lengthDrawn = 0;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i+1];
                const segmentLength = pointDistance(p1, p2);

                if (lengthDrawn + segmentLength <= drawableLength) {
                    ctx.lineTo(p2.x, p2.y);
                    lengthDrawn += segmentLength;
                } else {
                    const remainingLengthToDraw = drawableLength - lengthDrawn;
                    if (remainingLengthToDraw > 0 && segmentLength > 0) {
                        const fraction = remainingLengthToDraw / segmentLength;
                        const endX = p1.x + (p2.x - p1.x) * fraction;
                        const endY = p1.y + (p2.y - p1.y) * fraction;
                        ctx.lineTo(endX, endY);
                    }
                    break; 
                }
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawDebugAttackRangeHighlights() {
            if (gameState.currentActionState !== ACTION_STATES.SELECTING_ATTACK_TARGET) return;
            if (!gameState.debugAttackRangeHighlights || gameState.debugAttackRangeHighlights.length === 0) return;

            const currentTime = Date.now();
            const pulseProgress = (currentTime % PULSE_DURATION_MS) / PULSE_DURATION_MS; 
            const minOpacity = 0.0;
            const maxOpacity = 0.9;
            const opacity = minOpacity + (Math.sin(pulseProgress * 2 * Math.PI) + 1) / 2 * (maxOpacity - minOpacity);
            
            ctx.save();
            ctx.strokeStyle = `rgba(255, 140, 0, ${opacity})`; 
            ctx.lineWidth = 5; 

            gameState.debugAttackRangeHighlights.forEach(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (!edge) return;

                const p1_center = axialToPixel(edge.q1, edge.r1);
                const p2_center = axialToPixel(edge.q2, edge.r2);

                const edgeMidX = (p1_center.x + p2_center.x) / 2;
                const edgeMidY = (p1_center.y + p2_center.y) / 2;

                let dx_centers = p2_center.x - p1_center.x;
                let dy_centers = p2_center.y - p1_center.y;

                let perp_dx = -dy_centers;
                let perp_dy = dx_centers;

                const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
                if (len_perp_vec === 0) return; 

                const scale = (HEX_SIZE / 2) * 0.95; 
                perp_dx = (perp_dx / len_perp_vec) * scale;
                perp_dy = (perp_dy / len_perp_vec) * scale;

                ctx.beginPath();
                ctx.moveTo(edgeMidX + perp_dx, edgeMidY + perp_dy);
                ctx.lineTo(edgeMidX - perp_dx, edgeMidY - perp_dy);
                ctx.stroke();
            });
            ctx.restore();
        }


        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            gameState.tiles.forEach(tile => drawHexFill(tile.q, tile.r, tile.type.color));
            drawHexEdgesAndBoundaries();
            drawFortificationOutlines();
            drawContestedEdgeIndicator();
            drawBridges();
            drawFlags();
            drawSupplyLines();
            
            drawDebugAttackRangeHighlights()
            drawMovementHighlights(); 

            if (!gameState.isDragging) {
                switch(gameState.currentActionState) {
                    case ACTION_STATES.SELECTING_FORTIFY_TILE:
                        drawActionSelectionHighlights(gameState.validFortifyTargetTileKeys, 'fortify');
                        break;
                    case ACTION_STATES.SELECTING_UNFORTIFY_EDGE:
                        drawActionSelectionHighlights(gameState.validUnfortifyTargetEdgeKeys, 'unfortify');
                        break;
                    case ACTION_STATES.SELECTING_BRIDGE_EDGE:
                        drawActionSelectionHighlights(gameState.validBridgeTargetEdgeKeys, 'bridge');
                        break;
                    case ACTION_STATES.SELECTING_ATTACK_TARGET:
                        const currentAttackTargets = gameState.selectedUnit?.type.attackType === 'melee' 
                            ? gameState.validMeleeAttackTargets 
                            : gameState.validArcherAttackTargets;
                        drawBridgeAttackHighlightsOnly(currentAttackTargets); 
                        break;
                }
            }
            
            drawDebugPath();
            drawUnits();

             if (!gameState.isDragging && gameState.currentActionState === ACTION_STATES.SELECTING_ATTACK_TARGET) {
                 const currentAttackTargets = gameState.selectedUnit?.type.attackType === 'melee'
                    ? gameState.validMeleeAttackTargets 
                    : gameState.validArcherAttackTargets;
                 drawUnitAttackHighlightsOnly(currentAttackTargets); 
             }
            requestAnimationFrame(gameLoop);
        }

        // --- UI Update Functions ---
        function updateTurnDisplay() {
            if (ui.turnDisplay) {
                ui.turnDisplay.textContent = `Player ${gameState.currentPlayer}'s Turn`;
            } else {
                console.error('[UI Update] CRITICAL: ui.turnDisplay element is null or undefined!');
            }

            // NEW: Update canvas outline color based on the current player
            // Using the established UI colors for players
            const player1Color = '#5dade2';
            const player2Color = '#e74c3c';

            if (gameState.currentPlayer === 1) {
                canvas.style.outline = `4px solid ${player1Color}`;
            } else {
                canvas.style.outline = `4px solid ${player2Color}`;
            }
            // Add a small offset to make the outline look better
            canvas.style.outlineOffset = '2px';
        }

        function updateGlobalTurnDisplay() {
            if (ui.globalTurnCounterDisplay) {
                ui.globalTurnCounterDisplay.textContent = `Turn: ${gameState.globalTurnNumber}`;
            }
        }

        function updateActionButtonState(button, baseText, cancelText, isSelecting, canPerformCondition, additionalDisabledCondition = false) {
            button.textContent = isSelecting ? cancelText : baseText;
            button.classList.toggle('selecting', isSelecting);
            if (isSelecting) {
                button.disabled = false;
            } else {
                button.disabled = !canPerformCondition || additionalDisabledCondition;
            }
        }
        
        function updateSelectedUnitInfoPanel() {
            const { selectedUnit, currentActionState } = gameState;

            if (currentActionState !== ACTION_STATES.SELECTING_ATTACK_TARGET) {
                gameState.debugAttackRangeHighlights = [];
            }
            
            if (selectedUnit && !gameState.isDragging) {
                ui.selectedUnitInfoContainer.style.display = 'block';
                ui.actionInfoContainer.style.display = 'none';
                ui.actionsPanel.style.display = 'flex';
                ui.unitName.textContent = `${selectedUnit.type.name} (P${selectedUnit.player})`;
                ui.unitHP.textContent = selectedUnit.hp; ui.unitMaxHP.textContent = selectedUnit.maxHp;
                ui.unitMovement.textContent = Math.floor(selectedUnit.currentMove);
                ui.unitPosition.textContent = selectedUnit.positionType === 'edge' ? `Edge (${selectedUnit.position.substring(0,7)}...)` : `Center (${selectedUnit.position})`;
                let statusText = "Ready";
                if (selectedUnit.isCarryingFlag) statusText = "Carrying Flag";
                else if (selectedUnit.hp > selectedUnit.maxHp) statusText = "Shielded";
                else if (selectedUnit.isFortified) statusText = `Fortified on ${selectedUnit.fortifiedTileKey}`;
                else if (selectedUnit.hasPerformedMajorAction) statusText = "Action Taken";
                else if (selectedUnit.currentMove < 1) statusText = "No MP Left";
                ui.unitStatus.textContent = statusText;

                const canPerformMajorAction = !selectedUnit.hasPerformedMajorAction;
                const canAttack = selectedUnit.currentMove >= ATTACK_COST && !selectedUnit.hasPerformedMajorAction;

                if (selectedUnit.type.canFortify) {
                    ui.fortifyUnfortifyButton.style.display = 'inline-block';
                    const isSelectingFortify = currentActionState === ACTION_STATES.SELECTING_FORTIFY_TILE;
                    const isSelectingUnfortify = currentActionState === ACTION_STATES.SELECTING_UNFORTIFY_EDGE;
                    
                    let fortifyDisabledCondition = false;
                    if (selectedUnit.isFortified) { // Unfortify logic
                        if (!isSelectingUnfortify) {
                           fortifyDisabledCondition = getPotentialUnfortifyTargets(selectedUnit).length === 0;
                        }
                        updateActionButtonState(ui.fortifyUnfortifyButton, "Unfortify", "Cancel Unfortify", isSelectingUnfortify, canPerformMajorAction, fortifyDisabledCondition);
                    } else { // Fortify logic
                        if (!isSelectingFortify) {
                            const edgeCoords = parseEdgeKey(selectedUnit.position);
                            if (edgeCoords && edgeCoords.length === 2 && !isNaN(edgeCoords[0].q)) {
                                const tile1 = gameState.tiles.get(getTileKey(edgeCoords[0].q, edgeCoords[0].r));
                                const tile2 = gameState.tiles.get(getTileKey(edgeCoords[1].q, edgeCoords[1].r));
                                const canFortifyTile1 = tile1 && tile1.type.canFortify && tile1.fortifiedByPlayer === null;
                                const canFortifyTile2 = tile2 && tile2.type.canFortify && tile2.fortifiedByPlayer === null;
                                fortifyDisabledCondition = !(canFortifyTile1 || canFortifyTile2) || selectedUnit.positionType === 'center';
                            } else {
                                fortifyDisabledCondition = true;
                            }
                        }
                        updateActionButtonState(ui.fortifyUnfortifyButton, "Fortify", "Cancel Fortify", isSelectingFortify, canPerformMajorAction, fortifyDisabledCondition);
                    }
                } else {
                    ui.fortifyUnfortifyButton.style.display = 'none';
                }

                ui.buildBridgeButton.style.display = selectedUnit.type.canBuildBridge ? 'inline-block' : 'none';
                if (selectedUnit.type.canBuildBridge) {
                    const isSelectingBridge = currentActionState === ACTION_STATES.SELECTING_BRIDGE_EDGE;
                    let bridgeDisabledCondition = selectedUnit.isFortified;
                    if (!isSelectingBridge && !bridgeDisabledCondition) {
                        bridgeDisabledCondition = getPotentialBridgeTargets(selectedUnit).length === 0;
                    }
                    updateActionButtonState(ui.buildBridgeButton, "Build Bridge", "Cancel Bridge", isSelectingBridge, canPerformMajorAction, bridgeDisabledCondition);
                }

                ui.attackButton.style.display = selectedUnit.type.attackType ? 'inline-block' : 'none';
                if (selectedUnit.type.attackType) {
                    const isSelectingAttack = currentActionState === ACTION_STATES.SELECTING_ATTACK_TARGET;
                    let attackDisabledCondition = false;
                    if (!isSelectingAttack) {
                        if (selectedUnit.type.attackType === 'melee') {
                            attackDisabledCondition = getValidMeleeAttackTargets(selectedUnit).length === 0;
                        } else if (selectedUnit.type.attackType === 'ranged') {
                            attackDisabledCondition = getValidArcherAttackTargets(selectedUnit).length === 0;
                        }
                    }
                    updateActionButtonState(ui.attackButton, "Attack", "Cancel Attack", isSelectingAttack, canAttack, attackDisabledCondition);
                }
            } else if (!gameState.isDragging) {
                ui.selectedUnitInfoContainer.style.display = 'none';
                ui.actionInfoContainer.style.display = 'block';
                ui.actionsPanel.style.display = 'none';
                resetActionSelectionStates();
                ui.fortifyUnfortifyButton.textContent = "Fortify"; ui.fortifyUnfortifyButton.classList.remove('selecting');
                ui.buildBridgeButton.textContent = "Build Bridge"; ui.buildBridgeButton.classList.remove('selecting');
                ui.attackButton.textContent = "Attack"; ui.attackButton.classList.remove('selecting');
            }
        }

        function showRespawnModal(player) {
            const overlay = document.getElementById('respawnModalOverlay');
            const content = document.getElementById('respawnModalContent');
            if (!overlay || !content) return;

            // --- NEW: Check for total army size limit ---
            const currentUnitCount = gameState.units.filter(u => u.player === player).length;
            if (currentUnitCount >= MAX_UNITS_PER_PLAYER) {
                logAction(`P${player} has reached the maximum army size! Cannot reinforce.`, player);
                // Reset the timer for the unit in the queue so it can try again next turn.
                const queueKey = `player${player}`;
                if (gameState.respawnQueue[queueKey][0]) {
                    gameState.respawnQueue[queueKey][0].turnsRemaining = 1;
                }
                updateRespawnQueueDisplay(); // Show the reset timer
                return; // Exit without showing the modal
            }

            // --- Original Logic (now runs only if army size is okay) ---
            content.className = `modal-content modal-p${player}`;

            const counts = gameState.unitCounts[`player${player}`];
            
            const meleeButton = document.getElementById('respawnMelee');
            meleeButton.disabled = counts.Melee >= UNIT_CAPS.Melee;
            meleeButton.innerHTML = UNIT_SVGS.MELEE;

            const archerButton = document.getElementById('respawnArcher');
            archerButton.disabled = counts.Archer >= UNIT_CAPS.Archer;
            archerButton.innerHTML = UNIT_SVGS.ARCHER;
            
            const pikemanButton = document.getElementById('respawnPikeman');
            pikemanButton.disabled = counts.Pikeman >= UNIT_CAPS.Pikeman;
            pikemanButton.innerHTML = UNIT_SVGS.PIKEMAN;

            const horsemanButton = document.getElementById('respawnHorseman');
            horsemanButton.disabled = counts.Horseman >= UNIT_CAPS.Horseman;
            horsemanButton.innerHTML = UNIT_SVGS.HORSEMAN;

            overlay.style.display = 'flex';
            setTimeout(() => overlay.classList.add('modal-visible'), 10);
        }

        function hideRespawnModal() {
            const overlay = document.getElementById('respawnModalOverlay');
            if (!overlay) return;
            
            overlay.classList.remove('modal-visible');
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        }

        function updateRespawnQueueDisplay() {
            const container = document.getElementById('reinforcementsContainer');
            const listEl = document.getElementById('reinforcementsList');

            if (!container || !listEl) return;

            listEl.innerHTML = ''; 

            const p1Queue = gameState.respawnQueue.player1.map(item => ({ ...item, player: 1 }));
            const p2Queue = gameState.respawnQueue.player2.map(item => ({ ...item, player: 2 }));
            const combinedQueue = [...p1Queue, ...p2Queue];

            if (combinedQueue.length > 0) {
                container.style.display = 'block';
                combinedQueue.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `log-entry respawn-item log-p${item.player}`;
                    
                    const unitInfo = `
                        <div class="respawn-unit-info">
                            <span class="respawn-unit-symbol">${item.unitType.symbol}</span>
                            <span>${item.unitType.name}</span>
                        </div>`;
                    const timerInfo = `<div class="respawn-timer">${item.turnsRemaining} Turns</div>`;
                    
                    itemDiv.innerHTML = unitInfo + timerInfo;
                    listEl.appendChild(itemDiv);
                });
            } else {
                container.style.display = 'none';
            }
        }

        function showInstruction(message, duration = 3000) {
            ui.messageBox.textContent = message.replace(/<br>/g, ' '); 
            ui.messageBox.style.display = 'block';
            if (ui.messageBox.timeoutId) clearTimeout(ui.messageBox.timeoutId);
            ui.messageBox.timeoutId = setTimeout(() => { ui.messageBox.style.display = 'none'; }, duration);
        }

        function logAction(message, player, duration = 3000) {
            showInstruction(message, duration);
            gameState.actionLog.push({ message: message, player: player });
            if (gameState.actionLog.length > 10) {
                gameState.actionLog.shift();
            }
            updateActionLogDisplay();
        }
        
        // --- Game Logic Core ---
        function destroyUnit(unitToDestroy, reason = "destroyed") {
            const activePlayer = gameState.currentPlayer;

            gameState.unitCounts[`player${unitToDestroy.player}`][unitToDestroy.type.name]--;

            if (unitToDestroy.isCarryingFlag) {
                const flag = Object.values(gameState.flags).find(f => f.carrierId === unitToDestroy.id);
                if (flag) {
                    flag.status = 'at_base';
                    flag.carrierId = null;
                    unitToDestroy.isCarryingFlag = false; 
                    logAction(`The P${flag.player} flag has been returned to base!`, activePlayer);
                    recalculateSupplyLinesForPlayer(flag.player); // NEW: Recalculate supply lines for the flag's owner.
                }
            }
            
            const queueKey = `player${unitToDestroy.player}`;
            gameState.respawnQueue[queueKey].push({
                unitType: unitToDestroy.type,
                turnsRemaining: RESPAWN_TURN_TIMER
            });
            updateRespawnQueueDisplay();

            if (reason === "bridge_collapse") {
                logAction(`P${unitToDestroy.player} ${unitToDestroy.type.name} fell as the bridge collapsed!`, activePlayer, 3500);
            } else if (reason === "zoc_move" || reason === "zoc_turn_start" || reason === "fort_zoc") {
                logAction(`P${unitToDestroy.player} ${unitToDestroy.type.name} destroyed by ZoC!`, activePlayer, 3500);
            } else {
                logAction(`P${unitToDestroy.player} ${unitToDestroy.type.name} has been destroyed!`, activePlayer, 3000);
            }

            if (unitToDestroy.positionType === 'edge') {
                const edgeOfUnit = gameState.edges.get(unitToDestroy.position);
                if (edgeOfUnit) edgeOfUnit.units = edgeOfUnit.units.filter(u => u.id !== unitToDestroy.id);
            } else if (unitToDestroy.positionType === 'center' && unitToDestroy.isFortified) {
                const fortifiedTile = gameState.tiles.get(unitToDestroy.position);
                if (fortifiedTile && fortifiedTile.fortifiedByPlayer === unitToDestroy.player) fortifiedTile.fortifiedByPlayer = null;
            }

            gameState.units = gameState.units.filter(u => u.id !== unitToDestroy.id);

            if (gameState.selectedUnit && gameState.selectedUnit.id === unitToDestroy.id) {
                gameState.selectedUnit = null;
                gameState.currentReachableMoves.clear();
                resetActionSelectionStates();
                updateSelectedUnitInfoPanel();
            }
            if (gameState.hoveredUnitId === unitToDestroy.id) {
                gameState.hoveredUnitId = null;
                canvas.style.cursor = 'default';
            }
            if (gameState.draggingUnit && gameState.draggingUnit.id === unitToDestroy.id) {
                gameState.isDragging = false;
                gameState.draggingUnit = null;
                canvas.style.cursor = 'default';
            }

            checkVictoryCondition();
        }

        function getEdgeCost(unit, edgeKey) {
            const edge = gameState.edges.get(edgeKey); if (!edge) return Infinity;
            const tileCoords = parseEdgeKey(edgeKey);
            const tile1 = gameState.tiles.get(getTileKey(tileCoords[0].q, tileCoords[0].r));
            const tile2 = gameState.tiles.get(getTileKey(tileCoords[1].q, tileCoords[1].r));
            if (!tile1 || !tile2) return Infinity;
            let baseCost;
            if (edge.bridge) baseCost = 1;
            else {
                if (tile1.type === TILE_TYPES.WATER || tile2.type === TILE_TYPES.WATER) return Infinity;
                if (tile1.type === TILE_TYPES.MOUNTAIN || tile2.type === TILE_TYPES.MOUNTAIN) baseCost = TILE_TYPES.MOUNTAIN.baseMoveCost;
                else if (tile1.type === TILE_TYPES.FOREST || tile2.type === TILE_TYPES.FOREST) baseCost = TILE_TYPES.FOREST.baseMoveCost;
                else baseCost = TILE_TYPES.PLAINS.baseMoveCost;
            }
            let fortificationPenalty = 0; 
            const enemyPlayer = unit.player === 1 ? 2 : 1;
            const enemyBaseEdgeKey = FLAG_HOME_POSITIONS[`player${enemyPlayer}`];
            const enemyBaseTiles = [enemyBaseEdgeKey.split('_')[0], enemyBaseEdgeKey.split('_')[1]];

            if ((tile1.fortifiedByPlayer && tile1.fortifiedByPlayer === enemyPlayer) ||
                (tile2.fortifiedByPlayer && tile2.fortifiedByPlayer === enemyPlayer) ||
                enemyBaseTiles.includes(getTileKey(tile1.q, tile1.r)) ||
                enemyBaseTiles.includes(getTileKey(tile2.q, tile2.r))) 
            {
                fortificationPenalty = 1;
            }
            const finalCost = baseCost + fortificationPenalty;
            return Math.min(finalCost, MAX_MOVEMENT_COST);
        }

        // --- Pathfinding ---
        function getRotationallyAdjacentEdges(currentEdgeKey) {
            const adjacentEdges = new Set(); const [h1, h2] = parseEdgeKey(currentEdgeKey);
            if (isNaN(h1.q) || isNaN(h2.q)) return [];
            const findEdgesAroundPivot = (pivotHex, fromHex) => {
                const dirToFromHex = { q: fromHex.q - pivotHex.q, r: fromHex.r - pivotHex.r };
                const initialDirIndex = findDirectionIndex(dirToFromHex); if (initialDirIndex === -1) return;
                const ccwDirIndex = (initialDirIndex + 1) % 6; const cwDirIndex = (initialDirIndex + 5) % 6;
                const ccwNeighborCoords = { q: pivotHex.q + AXIAL_DIRECTIONS[ccwDirIndex].q, r: pivotHex.r + AXIAL_DIRECTIONS[ccwDirIndex].r };
                const cwNeighborCoords = { q: pivotHex.q + AXIAL_DIRECTIONS[cwDirIndex].q, r: pivotHex.r + AXIAL_DIRECTIONS[cwDirIndex].r };
                if (gameState.tiles.has(getTileKey(ccwNeighborCoords.q, ccwNeighborCoords.r))) adjacentEdges.add(getEdgeKey(pivotHex.q, pivotHex.r, ccwNeighborCoords.q, ccwNeighborCoords.r));
                if (gameState.tiles.has(getTileKey(cwNeighborCoords.q, cwNeighborCoords.r))) adjacentEdges.add(getEdgeKey(pivotHex.q, pivotHex.r, cwNeighborCoords.q, cwNeighborCoords.r));
            };
            findEdgesAroundPivot(h1, h2); findEdgesAroundPivot(h2, h1);
            return Array.from(adjacentEdges);
        }

        function getPossibleMoves(unit) {
            if (!unit || unit.currentMove < 1 || unit.isFortified) return new Map();
            
            if (unit.hasPerformedMajorAction) {
                if (!unit.type.canMoveAfterAttack) {
                    return new Map();
                }
                if (isEdgeAdjacentToSpearWall(unit, unit.position)) {
                    return new Map(); 
                }
            }

            const playerHomeFlagEdge = FLAG_HOME_POSITIONS[`player${unit.player}`];
            let reachable = new Map();
            let frontier = [{ edgeKey: unit.position, pathCost: 0, pathTaken: [unit.position] }];
            let minCostsFound = new Map(); minCostsFound.set(unit.position, 0);
            
            while (frontier.length > 0) {
                frontier.sort((a, b) => a.pathCost - b.pathCost); 
                const current = frontier.shift();

                if (current.pathCost > (minCostsFound.get(current.edgeKey) || Infinity)) continue;
                
                const rotationallyAdjacentEdges = getRotationallyAdjacentEdges(current.edgeKey);

                for (const nextAdjacentEdgeKey of rotationallyAdjacentEdges) {
                    // Add exception for flag carriers
                    // A unit cannot move onto its own team's flag edge, UNLESS it is carrying the enemy flag.
                    if (nextAdjacentEdgeKey === playerHomeFlagEdge && !unit.isCarryingFlag) {
                        continue;
                    }

                    if (nextAdjacentEdgeKey === unit.position && current.pathTaken.length === 1) continue;
                    const nextAdjacentEdgeObject = gameState.edges.get(nextAdjacentEdgeKey); if (!nextAdjacentEdgeObject) continue;
                    if (nextAdjacentEdgeObject.units.some(u => u.player !== unit.player)) continue;
                    const friendlyUnitsOnNext = nextAdjacentEdgeObject.units.filter(u => u.player === unit.player);
                    if (friendlyUnitsOnNext.length >= 2 && !friendlyUnitsOnNext.find(u => u.id === unit.id)) continue;
                    const costToTraverseNextEdge = getEdgeCost(unit, nextAdjacentEdgeKey); if (costToTraverseNextEdge === Infinity) continue;
                    const newTotalPathCost = current.pathCost + costToTraverseNextEdge;
                    if (newTotalPathCost <= unit.currentMove) {
                        const knownMinCost = minCostsFound.get(nextAdjacentEdgeKey) || Infinity;
                        if (newTotalPathCost < knownMinCost) {
                            minCostsFound.set(nextAdjacentEdgeKey, newTotalPathCost);
                            const newPathTaken = current.pathTaken.concat(nextAdjacentEdgeKey);
                            frontier.push({ edgeKey: nextAdjacentEdgeKey, pathCost: newTotalPathCost, pathTaken: newPathTaken });
                            if (nextAdjacentEdgeKey !== unit.position) reachable.set(nextAdjacentEdgeKey, { cost: newTotalPathCost, path: newPathTaken });
                        }
                    }
                }
            }
            return reachable;
        }

        function findSupplyPath(startFortTileKey, player) {
            // NEW: If the player's flag is stolen, they cannot have a supply line.
            const playerFlag = gameState.flags[`p${player}`];
            if (playerFlag && playerFlag.status === 'carried') {
                return null;
            }

            const baseEdgeKey = FLAG_HOME_POSITIONS[`player${player}`];
            const [baseH1, baseH2] = parseEdgeKey(baseEdgeKey);
            
            // The "start" for our pathfinding are all edges adjacent to the fort
            const startTile = gameState.tiles.get(startFortTileKey);
            if (!startTile) return null;
            const startEdges = getEdgesOfTile(startTile.q, startTile.r);
            
            // The "goals" are all edges adjacent to either base tile
            const endEdges = new Set([...getEdgesOfTile(baseH1.q, baseH1.r), ...getEdgesOfTile(baseH2.q, baseH2.r)]);

            let frontier = [];
            for (const edge of startEdges) {
                if (isRoad(edge)) {
                     frontier.push({ edgeKey: edge, cost: getEdgeCost({player}, edge), path: [edge] });
                }
            }

            let visited = new Map();
            startEdges.forEach(edge => visited.set(edge, { cost: 0, path: [] }));

            while (frontier.length > 0) {
                frontier.sort((a, b) => a.cost - b.cost);
                const current = frontier.shift();

            if (endEdges.has(current.edgeKey)) {
            // Return the path, but remove the first and last edge for a cleaner visual.
                const visualPath = current.path.length > 2 ? current.path.slice(1, -1) : [];
                return { path: visualPath, cost: current.cost };
            }

                const adjacentEdges = getRotationallyAdjacentEdges(current.edgeKey);
                for (const neighborEdgeKey of adjacentEdges) {
                    if (!isRoad(neighborEdgeKey)) continue;

                    const costToNeighbor = getEdgeCost({ player }, neighborEdgeKey);
                    const newCost = current.cost + costToNeighbor;

                    if (!visited.has(neighborEdgeKey) || newCost < visited.get(neighborEdgeKey).cost) {
                        const newPath = [...current.path, neighborEdgeKey];
                        visited.set(neighborEdgeKey, { cost: newCost, path: newPath });
                        frontier.push({ edgeKey: neighborEdgeKey, cost: newCost, path: newPath });
                    }
                }
            }

            return null; // No path found
        }

        function severSupplyLinesForPlayer(playerNum) {
            logAction(`P${playerNum}'s flag was stolen! Supply lines have been cut.`, playerNum === 1 ? 2 : 1);
            gameState.units.forEach(unit => {
                if (unit.player === playerNum && unit.isFortified) {
                    unit.supplyLine = null;
                }
            });
        }

        function recalculateSupplyLinesForPlayer(playerNum) {
            logAction(`P${playerNum}'s flag has been returned! Supply lines are re-established.`, playerNum);
            gameState.units.forEach(unit => {
                if (unit.player === playerNum && unit.isFortified) {
                    const playerBaseTiles = [FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[0], FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[1]];
                    if (!playerBaseTiles.includes(unit.fortifiedTileKey)) {
                        unit.supplyLine = findSupplyPath(unit.fortifiedTileKey, unit.player);
                    }
                }
            });
        }

        // --- Action: Fortify / Unfortify ---
        function getPotentialUnfortifyTargets(unit) {
            if (!unit || !unit.isFortified || unit.positionType !== 'center') return [];
            const fortifiedTile = gameState.tiles.get(unit.position); if (!fortifiedTile) return [];
            const validTargets = [];
            getNeighbors(fortifiedTile.q, fortifiedTile.r).forEach(neighborCoords => {
                const edgeKey = getEdgeKey(fortifiedTile.q, fortifiedTile.r, neighborCoords.q, neighborCoords.r);
                const edge = gameState.edges.get(edgeKey);
                if (edge && getEdgeCost(unit, edgeKey) !== Infinity) {
                     const enemyOnEdge = edge.units.some(u => u.player !== unit.player);
                     const friendliesOnEdge = edge.units.filter(u => u.player === unit.player).length;
                     if (!enemyOnEdge && friendliesOnEdge < 2) validTargets.push(edgeKey);
                 }
             });
             return validTargets;
        }

        function completeFortify(targetTileKeyToFortify) {
            const { selectedUnit } = gameState;
             if (!selectedUnit || selectedUnit.hasPerformedMajorAction || selectedUnit.isFortified) { showInstruction("Cannot fortify now.", 2000); return; }
            const targetTileObject = gameState.tiles.get(targetTileKeyToFortify);
            if (!targetTileObject || !targetTileObject.type.canFortify) { showInstruction("Invalid tile to fortify.", 2000); return; }
            if (targetTileObject.fortifiedByPlayer !== null) {
                showInstruction(`Tile ${targetTileKeyToFortify.substring(0,5)}... already fortified.`, 2500);
                resetActionSelectionStates(); 
                updateSelectedUnitInfoPanel(); return;
            }
            const fortifyingPlayer = selectedUnit.player;
            const currentEdge = gameState.edges.get(selectedUnit.position);
            if (currentEdge) currentEdge.units = currentEdge.units.filter(u => u.id !== selectedUnit.id);
            selectedUnit.isFortified = true; selectedUnit.fortifiedTileKey = targetTileKeyToFortify;
            selectedUnit.positionType = 'center'; selectedUnit.position = targetTileKeyToFortify;
            selectedUnit.currentMove = 0; selectedUnit.hasPerformedMajorAction = true;
            targetTileObject.fortifiedByPlayer = fortifyingPlayer;
            logAction(`${selectedUnit.type.name} fortified on tile ${targetTileKeyToFortify.substring(0,5)}...`, gameState.currentPlayer, 2500);
            
            // --- NEW: Calculate and store the supply line ---
            const playerBaseEdgeKey = FLAG_HOME_POSITIONS[`player${fortifyingPlayer}`];
            const playerBaseTiles = [playerBaseEdgeKey.split('_')[0], playerBaseEdgeKey.split('_')[1]];
            
            if (!playerBaseTiles.includes(targetTileKeyToFortify)) {
                const supplyPathData = findSupplyPath(targetTileKeyToFortify, fortifyingPlayer);
                selectedUnit.supplyLine = supplyPathData;
            }
            // --- END OF NEW LOGIC ---

            let unitsToDestroy = [];
            getNeighbors(targetTileObject.q, targetTileObject.r).forEach(neighborCoords => {
                 const edgeKey = getEdgeKey(targetTileObject.q, targetTileObject.r, neighborCoords.q, neighborCoords.r);
                 const adjacentEdge = gameState.edges.get(edgeKey);
                 if (adjacentEdge) {
                     adjacentEdge.units.forEach(enemyUnit => {
                         if (enemyUnit.player !== fortifyingPlayer && enemyUnit.positionType === 'edge') {
                             enemyUnit.hp -= FORTIFICATION_DAMAGE;
                             logAction(`P${enemyUnit.player} ${enemyUnit.type.name} takes ZoC. HP: ${enemyUnit.hp}`, gameState.currentPlayer);
                             if (enemyUnit.hp <= 0 && !unitsToDestroy.find(u => u.id === enemyUnit.id)) unitsToDestroy.push(enemyUnit);
                         }
                     });
                 }
             });
            unitsToDestroy.forEach(u => destroyUnit(u, "fort_zoc"));
            gameState.currentReachableMoves.clear();
            resetActionSelectionStates();
            updateSelectedUnitInfoPanel(); 
            if (!gameState.gameOver) checkVictoryCondition();
        }

        function handleFortifyActionLogic() {
            const { selectedUnit } = gameState;
             if (!selectedUnit || selectedUnit.hasPerformedMajorAction || selectedUnit.isFortified || selectedUnit.positionType !== 'edge') { showInstruction("Cannot fortify.", 2000); return; }
            const edgeCoords = parseEdgeKey(selectedUnit.position);
             if (!edgeCoords || edgeCoords.length !== 2 || isNaN(edgeCoords[0].q)) { showInstruction("Unit not on valid edge.", 2000); return; }
            const tile1Key = getTileKey(edgeCoords[0].q, edgeCoords[0].r); const tile2Key = getTileKey(edgeCoords[1].q, edgeCoords[1].r);
            const tile1 = gameState.tiles.get(tile1Key); const tile2 = gameState.tiles.get(tile2Key);
            gameState.validFortifyTargetTileKeys = [];
            if (tile1 && tile1.type.canFortify && tile1.fortifiedByPlayer === null) gameState.validFortifyTargetTileKeys.push(tile1Key);
            if (tile2 && tile2.type.canFortify && tile2.fortifiedByPlayer === null) gameState.validFortifyTargetTileKeys.push(tile2Key);
            if (gameState.validFortifyTargetTileKeys.length === 0) { showInstruction("No valid adjacent tile.", 2000); return; }
            if (gameState.validFortifyTargetTileKeys.length === 1) {
                completeFortify(gameState.validFortifyTargetTileKeys[0]);
            } else { 
                gameState.currentActionState = ACTION_STATES.SELECTING_FORTIFY_TILE;
                showInstruction("Select tile to fortify.", 3000); 
            }
            updateSelectedUnitInfoPanel();
        }

        function completeUnfortify(targetEdgeKey) {
            const { selectedUnit } = gameState;
            if (!selectedUnit || !selectedUnit.isFortified || selectedUnit.hasPerformedMajorAction) { showInstruction("Cannot unfortify.", 2000); return; }
            const targetEdge = gameState.edges.get(targetEdgeKey); if (!targetEdge) { showInstruction("Invalid target edge.", 2000); return; }
            if (targetEdge.units.some(u => u.player !== selectedUnit.player) || targetEdge.units.filter(u => u.player === selectedUnit.player).length >= 2) {
                 showInstruction("Target edge blocked.", 2000); 
                 resetActionSelectionStates();
                 updateSelectedUnitInfoPanel(); 
                 return;
            }
            const oldFortifiedTile = gameState.tiles.get(selectedUnit.fortifiedTileKey);
            if (oldFortifiedTile) oldFortifiedTile.fortifiedByPlayer = null;
            selectedUnit.isFortified = false;
            selectedUnit.turnsFortifiedAtBase = 0;
            selectedUnit.supplyLine = null; // Clear the supply line
            selectedUnit.fortifiedTileKey = null;
            selectedUnit.positionType = 'edge'; 
            selectedUnit.position = targetEdgeKey;
            selectedUnit.currentMove = 0; 
            selectedUnit.hasPerformedMajorAction = true;
            targetEdge.units.push(selectedUnit);
            logAction(`${selectedUnit.type.name} unfortified to ${targetEdgeKey.substring(0,7)}...`, gameState.currentPlayer, 2500);
            resetActionSelectionStates();
            updateSelectedUnitInfoPanel();
        }

        function handleUnfortifyActionLogic() {
            const { selectedUnit } = gameState;
            if (!selectedUnit || !selectedUnit.isFortified || selectedUnit.hasPerformedMajorAction) { showInstruction("Cannot unfortify.", 2000); return; }
            gameState.validUnfortifyTargetEdgeKeys = getPotentialUnfortifyTargets(selectedUnit);
            if (gameState.validUnfortifyTargetEdgeKeys.length === 0) { showInstruction("No valid edge to unfortify to.", 2500); return; }
            
            gameState.currentActionState = ACTION_STATES.SELECTING_UNFORTIFY_EDGE;
            showInstruction("Select edge to move to.", 3000); 
            updateSelectedUnitInfoPanel();
        }

        function handleFortifyUnfortifyButtonClick() {
            if (gameState.isDragging) return; 
            const { selectedUnit } = gameState; 
            if (!selectedUnit) return;

            if (gameState.currentActionState === ACTION_STATES.SELECTING_FORTIFY_TILE || gameState.currentActionState === ACTION_STATES.SELECTING_UNFORTIFY_EDGE) {
                const message = gameState.currentActionState === ACTION_STATES.SELECTING_FORTIFY_TILE ? "Fortify cancelled." : "Unfortify cancelled.";
                resetActionSelectionStates();
                showInstruction(message, 1500);
            } else if (selectedUnit.isFortified) {
                handleUnfortifyActionLogic();
            } else {
                handleFortifyActionLogic();
            }
            updateSelectedUnitInfoPanel();
        }

        // --- Action: Build Bridge ---
        function getPotentialBridgeTargets(unit) {
            if (!unit || unit.positionType !== 'edge' || !unit.type.canBuildBridge || unit.isFortified) return [];

            const rotationallyAdjacentEdges = getRotationallyAdjacentEdges(unit.position);
            
            return rotationallyAdjacentEdges.filter(adjEdgeKey => {
                if (adjEdgeKey === unit.position) return false; 
                
                const edgeData = gameState.edges.get(adjEdgeKey);
                if (edgeData && !edgeData.bridge) { 
                    const adjEdgeTileCoords = parseEdgeKey(adjEdgeKey);
                    if (adjEdgeTileCoords.some(coord => isNaN(coord.q))) return false;

                    const t1 = gameState.tiles.get(getTileKey(adjEdgeTileCoords[0].q, adjEdgeTileCoords[0].r));
                    const t2 = gameState.tiles.get(getTileKey(adjEdgeTileCoords[1].q, adjEdgeTileCoords[1].r));
                    
                    return (t1 && t1.type === TILE_TYPES.WATER) || (t2 && t2.type === TILE_TYPES.WATER);
                }
                return false;
            });
        }


        function handleBuildBridgeAction() {
            if (gameState.isDragging) return; 
            const { selectedUnit } = gameState;

            if (gameState.currentActionState === ACTION_STATES.SELECTING_BRIDGE_EDGE) {
                resetActionSelectionStates();
                showInstruction("Bridge selection cancelled.", 1500);
                updateSelectedUnitInfoPanel(); 
                return;
            }
            if (!selectedUnit || !selectedUnit.type.canBuildBridge || selectedUnit.isFortified || selectedUnit.hasPerformedMajorAction) {
                showInstruction(selectedUnit && selectedUnit.hasPerformedMajorAction ? "Unit acted." : "Cannot build bridge.", 2000); 
                return;
            }
            gameState.validBridgeTargetEdgeKeys = getPotentialBridgeTargets(selectedUnit);
            if (gameState.validBridgeTargetEdgeKeys.length === 0) {
                showInstruction("No valid water edge for bridge.", 2000);
            } else { 
                gameState.currentActionState = ACTION_STATES.SELECTING_BRIDGE_EDGE;
                showInstruction("Select water edge for bridge.", 3000); 
            }
            updateSelectedUnitInfoPanel();
        }

        function completeBuildBridge(targetEdgeKey) {
            const { selectedUnit } = gameState;
            if (!selectedUnit || !selectedUnit.type.canBuildBridge || selectedUnit.hasPerformedMajorAction || selectedUnit.isFortified) {
                 showInstruction("Cannot build bridge.", 2000); 
                 resetActionSelectionStates();
                 updateSelectedUnitInfoPanel(); 
                 return;
            }
            const edgeToBridge = gameState.edges.get(targetEdgeKey);
            if (!edgeToBridge || edgeToBridge.bridge) {
                showInstruction("Cannot build bridge here.", 2000); 
                resetActionSelectionStates();
                updateSelectedUnitInfoPanel(); 
                return;
            }
            edgeToBridge.bridge = true; 
            edgeToBridge.bridgeHp = BRIDGE_MAX_HP;
            selectedUnit.currentMove = 0; 
            selectedUnit.hasPerformedMajorAction = true;
            logAction(`${selectedUnit.type.name} built bridge on ${targetEdgeKey.substring(0,7)}... HP: ${edgeToBridge.bridgeHp}`, gameState.currentPlayer, 3000);
            resetActionSelectionStates();
            updateSelectedUnitInfoPanel();
        }

        // --- Action: Movement & Fortification Damage ---
        function applyFortificationDamageOnMove(unitMoving, newEdgeKey) {
             if (!unitMoving || unitMoving.isFortified || unitMoving.positionType !== 'edge') return false;
            const tileCoords = parseEdgeKey(newEdgeKey); 
            if (tileCoords.some(coord => isNaN(coord.q))) return false;
            let unitDestroyed = false; const enemyPlayer = unitMoving.player === 1 ? 2 : 1;
            const checkAndApply = (tile) => {
                if (tile && tile.fortifiedByPlayer === enemyPlayer && !unitDestroyed) {
                    unitMoving.hp -= FORTIFICATION_DAMAGE;
                    logAction(`P${unitMoving.player} ${unitMoving.type.name} takes ZoC. HP: ${unitMoving.hp}`, gameState.currentPlayer, 3500);
                    if (unitMoving.hp <= 0) { destroyUnit(unitMoving, "zoc_move"); unitDestroyed = true; }
                    return true;
                } return false;
            };
            const tile1 = gameState.tiles.get(getTileKey(tileCoords[0].q, tileCoords[0].r));
            const tile2 = gameState.tiles.get(getTileKey(tileCoords[1].q, tileCoords[1].r));
            checkAndApply(tile1); checkAndApply(tile2);
            return unitDestroyed;
        }


        // --- Action: Attack (Melee & Archer) ---
        function getPotentialMeleeAttackEdges(attackingUnit) {
            const potentialEdges = new Set();
            if (!attackingUnit) return Array.from(potentialEdges);

            if (attackingUnit.isFortified && attackingUnit.positionType === 'center') {
                const fortifiedTile = gameState.tiles.get(attackingUnit.position);
                if (!fortifiedTile) return Array.from(potentialEdges);
                getNeighbors(fortifiedTile.q, fortifiedTile.r).forEach(neighborCoords => {
                    if (gameState.tiles.has(getTileKey(neighborCoords.q, neighborCoords.r))) {
                        const edgeKey = getEdgeKey(fortifiedTile.q, fortifiedTile.r, neighborCoords.q, neighborCoords.r);
                        potentialEdges.add(edgeKey);
                    }
                });
            } else if (attackingUnit.positionType === 'edge') {
                return getRotationallyAdjacentEdges(attackingUnit.position);
            }
            return Array.from(potentialEdges);
        }

        function getPotentialArcherAttackEdges(attackingUnit) {
            const potentialEdges = new Set();
            if (!attackingUnit || attackingUnit.type.name !== 'Archer') return Array.from(potentialEdges);

            if (attackingUnit.isFortified && attackingUnit.positionType === 'center') {
                const attackerTileKey = attackingUnit.position;
                const attackerTile = gameState.tiles.get(attackerTileKey);
                if (!attackerTile) return Array.from(potentialEdges);
                getNeighbors(attackerTile.q, attackerTile.r).forEach(neighborCoords => {
                    const neighborKey = getTileKey(neighborCoords.q, neighborCoords.r);
                    if (gameState.tiles.has(neighborKey)) {
                        potentialEdges.add(getEdgeKey(attackerTile.q, attackerTile.r, neighborCoords.q, neighborCoords.r));
                    }
                });
            } else if (attackingUnit.positionType === 'edge') {
                const currentUnitEdgeKey = attackingUnit.position;
                const [H1_coords, H2_coords] = parseEdgeKey(currentUnitEdgeKey);
                if (isNaN(H1_coords.q) || isNaN(H2_coords.q)) return Array.from(potentialEdges);

                const processHex = (hexCoords) => {
                    if (gameState.tiles.has(getTileKey(hexCoords.q, hexCoords.r))) {
                        getNeighbors(hexCoords.q, hexCoords.r).forEach(neighbor_coords => {
                            if (gameState.tiles.has(getTileKey(neighbor_coords.q, neighbor_coords.r))) {
                                const edgeToAdd = getEdgeKey(hexCoords.q, hexCoords.r, neighbor_coords.q, neighbor_coords.r);
                                potentialEdges.add(edgeToAdd); 
                            }
                        });
                    }
                };
                processHex(H1_coords);
                processHex(H2_coords);
            }
            return Array.from(potentialEdges);
        }

        function getValidMeleeAttackTargets(attackingUnit) {
            if (!attackingUnit || attackingUnit.currentMove < ATTACK_COST || attackingUnit.hasPerformedMajorAction) return [];
            const targets = [];
            const addUnitTarget = (targetUnit, edgeKey = null, tileKeyForTarget = null) => {
                if (!targets.some(t => t.unit && t.unit.id === targetUnit.id)) targets.push({ unit: targetUnit, edgeKey, tileKeyForTarget, isBridgeTarget: false });
            };
            const addBridgeTarget = (edgeKey) => {
                 if (!targets.some(t => t.isBridgeTarget && t.edgeKey === edgeKey)) targets.push({ unit: null, edgeKey, tileKeyForTarget: null, isBridgeTarget: true });
            }
            
            const potentialAttackEdges = getPotentialMeleeAttackEdges(attackingUnit);

            potentialAttackEdges.forEach(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    edge.units.forEach(unitOnEdge => { 
                        if (unitOnEdge.player !== attackingUnit.player && unitOnEdge.positionType === 'edge') {
                            addUnitTarget(unitOnEdge, edgeKey); 
                        }
                    });
                     if (edge.bridge && edge.bridgeHp > 0) addBridgeTarget(edgeKey);
                }
            });
            
            if (attackingUnit.positionType === 'edge') { 
                const [H1_coords, H2_coords] = parseEdgeKey(attackingUnit.position);
                [H1_coords, H2_coords].forEach(hexCoords => { 
                     if (isNaN(hexCoords.q)) return;
                    const tileKey = getTileKey(hexCoords.q, hexCoords.r);
                    const tile = gameState.tiles.get(tileKey);
                    if (tile && tile.fortifiedByPlayer && tile.fortifiedByPlayer !== attackingUnit.player) {
                        const fortifiedUnit = gameState.units.find(u => u.isFortified && u.position === tileKey && u.player === tile.fortifiedByPlayer);
                        if (fortifiedUnit) {
                            addUnitTarget(fortifiedUnit, null, tileKey);
                        }
                    }
                });
            }
            return targets;
        }

        function canArcherOnEdgeSeeEdge(archerEdgeKey, targetEdgeKey, archerTile1, archerTile2) {
            let blockedByTile1 = false;
            if (archerTile1.type === TILE_TYPES.MOUNTAIN) {
                if (isEdgePartOfTile(archerTile1.q, archerTile1.r, targetEdgeKey) && targetEdgeKey !== archerEdgeKey) {
                    blockedByTile1 = true;
                }
            } else if (archerTile1.type === TILE_TYPES.FOREST) {
                if (isEdgePartOfTile(archerTile1.q, archerTile1.r, targetEdgeKey) &&
                    targetEdgeKey !== archerEdgeKey &&
                    !isEdgeRotationallyAdjacentToEdgeOnTile(archerTile1.q, archerTile1.r, archerEdgeKey, targetEdgeKey)) {
                    blockedByTile1 = true;
                }
            }

            let blockedByTile2 = false;
            if (archerTile2.type === TILE_TYPES.MOUNTAIN) {
                if (isEdgePartOfTile(archerTile2.q, archerTile2.r, targetEdgeKey) && targetEdgeKey !== archerEdgeKey) {
                    blockedByTile2 = true;
                }
            } else if (archerTile2.type === TILE_TYPES.FOREST) {
                if (isEdgePartOfTile(archerTile2.q, archerTile2.r, targetEdgeKey) &&
                    targetEdgeKey !== archerEdgeKey &&
                    !isEdgeRotationallyAdjacentToEdgeOnTile(archerTile2.q, archerTile2.r, archerEdgeKey, targetEdgeKey)) {
                    blockedByTile2 = true;
                }
            }
            return !blockedByTile1 && !blockedByTile2;
        }
        
        function canArcherOnEdgeSeeFortified(archerEdgeKey, targetFortifiedTileKey, archerTile1, archerTile2) {
            const targetFortifiedTile = gameState.tiles.get(targetFortifiedTileKey);
            if (!targetFortifiedTile) return false;

            let obstructed = false;
            if (archerTile1.type === TILE_TYPES.FOREST) {
                const connectingEdgeKey = getEdgeKey(archerTile1.q, archerTile1.r, targetFortifiedTile.q, targetFortifiedTile.r);
                if (gameState.edges.has(connectingEdgeKey)) { 
                    if (!isEdgeRotationallyAdjacentToEdgeOnTile(archerTile1.q, archerTile1.r, archerEdgeKey, connectingEdgeKey)) {
                        obstructed = true; 
                    }
                }
            }

            if (!obstructed && archerTile2.type === TILE_TYPES.FOREST) {
                const connectingEdgeKey = getEdgeKey(archerTile2.q, archerTile2.r, targetFortifiedTile.q, targetFortifiedTile.r);
                 if (gameState.edges.has(connectingEdgeKey)) { 
                    if (!isEdgeRotationallyAdjacentToEdgeOnTile(archerTile2.q, archerTile2.r, archerEdgeKey, connectingEdgeKey)) {
                        obstructed = true;
                    }
                }
            }
            if (obstructed) return false;

            const [archerH1_coords, archerH2_coords] = parseEdgeKey(archerEdgeKey);
            
            let isRotationallyValid = false;
            const connectingEdge1_key = getEdgeKey(archerH1_coords.q, archerH1_coords.r, targetFortifiedTile.q, targetFortifiedTile.r);
            if (gameState.edges.has(connectingEdge1_key)) { 
                if (isEdgeRotationallyAdjacentToEdgeOnTile(archerH1_coords.q, archerH1_coords.r, archerEdgeKey, connectingEdge1_key)) {
                    isRotationallyValid = true;
                }
            }
            
            if (!isRotationallyValid) { 
                const connectingEdge2_key = getEdgeKey(archerH2_coords.q, archerH2_coords.r, targetFortifiedTile.q, targetFortifiedTile.r);
                 if (gameState.edges.has(connectingEdge2_key)) { 
                    if (isEdgeRotationallyAdjacentToEdgeOnTile(archerH2_coords.q, archerH2_coords.r, archerEdgeKey, connectingEdge2_key)) {
                        isRotationallyValid = true;
                    }
                }
            }
            
            return isRotationallyValid;
        }

        function canFortifiedArcherSee(attackingUnit, targetInfo) {
            const archerFortTileKey = attackingUnit.position;
            const archerFortTile = gameState.tiles.get(archerFortTileKey);
            if (!archerFortTile) return false;

            if (archerFortTile.type === TILE_TYPES.FOREST) {
                if (targetInfo.isBridgeTarget || (targetInfo.unit && !targetInfo.unit.isFortified)) {
                    return isEdgePartOfTile(archerFortTile.q, archerFortTile.r, targetInfo.edgeKey);
                } else if (targetInfo.unit.isFortified) {
                    const targetTileKey = targetInfo.tileKeyForTarget;
                    const targetTile = gameState.tiles.get(targetTileKey);
                    if (!targetTile) return false;
                    const isAdjacent = axialDistance(archerFortTile.q, archerFortTile.r, targetTile.q, targetTile.r) === 1;
                    return isAdjacent && targetTile.type !== TILE_TYPES.FOREST;
                }
            }

            if (targetInfo.unit && targetInfo.unit.isFortified) {
                const targetTile = gameState.tiles.get(targetInfo.tileKeyForTarget);
                if (targetTile && targetTile.type === TILE_TYPES.FOREST) {
                    return false;
                }
            }
            return true;
        }

        function canEdgeArcherSee(attackingUnit, targetInfo) {
            const archerEdgeKey = attackingUnit.position;
            const [archerH1, archerH2] = parseEdgeKey(archerEdgeKey);
            const archerTile1 = gameState.tiles.get(getTileKey(archerH1.q, archerH1.r));
            const archerTile2 = gameState.tiles.get(getTileKey(archerH2.q, archerH2.r));
            if (!archerTile1 || !archerTile2) return false;

            if (targetInfo.isBridgeTarget || (targetInfo.unit && !targetInfo.unit.isFortified)) {
                return canArcherOnEdgeSeeEdge(archerEdgeKey, targetInfo.edgeKey, archerTile1, archerTile2);
            }
            
            if (targetInfo.unit && targetInfo.unit.isFortified) {
                const targetTileKey = targetInfo.tileKeyForTarget;
                const targetTile = gameState.tiles.get(targetTileKey);
                if (!targetTile) return false;

                if (targetTile.type === TILE_TYPES.FOREST) {
                    if (!isEdgePartOfTile(targetTile.q, targetTile.r, archerEdgeKey)) {
                        return false; 
                    }
                }
                
                const isImmediatelyAdjacentFort = (targetTileKey === getTileKey(archerH1.q, archerH1.r) || targetTileKey === getTileKey(archerH2.q, archerH2.r));
                if (isImmediatelyAdjacentFort) {
                    const archerEdge = gameState.edges.get(archerEdgeKey);
                    const hasMeleeSpotter = archerEdge.units.some(u => u.player === attackingUnit.player && u.type.name === 'Melee');
                    return hasMeleeSpotter;
                } else {
                    return canArcherOnEdgeSeeFortified(archerEdgeKey, targetTileKey, archerTile1, archerTile2);
                }
            }
            
            return false;
        }

        function getValidArcherAttackTargets(attackingUnit) {
            if (!attackingUnit || attackingUnit.currentMove < ATTACK_COST || attackingUnit.hasPerformedMajorAction || attackingUnit.type.name !== 'Archer') {
                return [];
            }

            const potentialAttackEdges = getPotentialArcherAttackEdges(attackingUnit);
            const potentialTargetableTiles = new Set();
            potentialAttackEdges.forEach(edgeKey => {
                const [c1, c2] = parseEdgeKey(edgeKey);
                if (!isNaN(c1.q)) potentialTargetableTiles.add(getTileKey(c1.q, c1.r));
                if (!isNaN(c2.q)) potentialTargetableTiles.add(getTileKey(c2.q, c2.r));
            });

            const potentialTargets = [];
            const addPotentialUnit = (unit, edgeKey = null, tileKey = null) => {
                if (!potentialTargets.some(t => t.unit && t.unit.id === unit.id)) {
                    potentialTargets.push({ unit: unit, edgeKey: edgeKey, tileKeyForTarget: tileKey, isBridgeTarget: false });
                }
            };
            const addPotentialBridge = (edgeKey) => {
                if (!potentialTargets.some(t => t.isBridgeTarget && t.edgeKey === edgeKey)) {
                    potentialTargets.push({ unit: null, edgeKey: edgeKey, tileKeyForTarget: null, isBridgeTarget: true });
                }
            };

            potentialAttackEdges.forEach(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    edge.units.forEach(unit => {
                        if (unit.player !== attackingUnit.player) {
                            addPotentialUnit(unit, edgeKey, null);
                        }
                    });
                    if (edge.bridge && edge.bridgeHp > 0) {
                        addPotentialBridge(edgeKey);
                    }
                }
            });
            potentialTargetableTiles.forEach(tileKey => {
                const tile = gameState.tiles.get(tileKey);
                if (tile && tile.fortifiedByPlayer && tile.fortifiedByPlayer !== attackingUnit.player) {
                    const fortifiedUnit = gameState.units.find(u => u.isFortified && u.position === tileKey);
                    if (fortifiedUnit) {
                        addPotentialUnit(fortifiedUnit, null, tileKey);
                    }
                }
            });
            
            return potentialTargets.filter(targetInfo => {
                if (attackingUnit.isFortified) {
                    return canFortifiedArcherSee(attackingUnit, targetInfo);
                } else { 
                    return canEdgeArcherSee(attackingUnit, targetInfo);
                }
            });
        }


        function handleAttackAction() {
            if (gameState.isDragging) return; 
            const { selectedUnit } = gameState;
            
            if (gameState.currentActionState === ACTION_STATES.SELECTING_ATTACK_TARGET) {
                 resetActionSelectionStates(); 
                 showInstruction("Attack cancelled.", 1500); 
                 updateSelectedUnitInfoPanel(); 
                 return;
            }

             if (!selectedUnit || selectedUnit.currentMove < ATTACK_COST || selectedUnit.hasPerformedMajorAction) {
                showInstruction(selectedUnit && selectedUnit.hasPerformedMajorAction ? "Unit acted." : "Cannot attack.", 2500); return;
            }

            gameState.debugAttackRangeHighlights = []; 

            if (selectedUnit.type.attackType === 'melee') {
                gameState.validMeleeAttackTargets = getValidMeleeAttackTargets(selectedUnit);
                gameState.debugAttackRangeHighlights = gameState.validMeleeAttackTargets
                    .filter(t => t.edgeKey && !t.isBridgeTarget)
                    .map(t => t.edgeKey);

                if (gameState.validMeleeAttackTargets.length === 0) {
                    showInstruction("No valid melee targets.", 2000);
                } else {
                    gameState.currentActionState = ACTION_STATES.SELECTING_ATTACK_TARGET;
                    showInstruction("Select target to attack.", 3000);
                }
            } else if (selectedUnit.type.attackType === 'ranged') {
                gameState.validArcherAttackTargets = getValidArcherAttackTargets(selectedUnit);
                gameState.debugAttackRangeHighlights = gameState.validArcherAttackTargets
                    .filter(t => t.edgeKey && !t.isBridgeTarget)
                    .map(t => t.edgeKey);

                if (gameState.validArcherAttackTargets.length === 0) {
                    showInstruction("No valid archer targets.", 2000);
                } else {
                    gameState.currentActionState = ACTION_STATES.SELECTING_ATTACK_TARGET;
                    showInstruction("Select target to attack.", 3000);
                }
            }
            updateSelectedUnitInfoPanel();
        }

        function getActionIcon(message) {
            let iconSvg = '';
            const iconColor = '#bdc3c7';

            if (message.includes('hits') || message.includes('takes') || message.includes('targets bridge') || message.includes('retaliates')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15.2 3.8-3.5 3.5 4.3 4.3 3.5-3.5-4.3-4.3z"/><path d="m4.1 19.9 4.4-4.4"/><path d="M16 16h3v3"/><path d="M10.1 5.5 3 12.6l-1.4 1.4 4.2 4.2 1.4-1.4 7.1-7.1"/><path d="M12.6 3 3 12.6l4.2 4.2 9.6-9.6L12.6 3z"/></svg>`;
            } else if (message.includes('fortified')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>`;
            } else if (message.includes('unfortified')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;
            } else if (message.includes('healed') || message.includes('gained a shield')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>`;
            } else if (message.includes('destroyed')) {
                 iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="12" r="1"></circle><circle cx="15" cy="12" r="1"></circle><path d="M8 20v2h8v-2"></path><path d="m12.5 17.5-1-1-1 1"></path><path d="M16 20a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2"></path><path d="M16 20a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2"></path><path d="M15 2h-1.5a1.5 1.5 0 0 0 0 3h1.5a1.5 1.5 0 0 0 0-3Z"></path><path d="M9 2H7.5a1.5 1.5 0 0 0 0 3H9a1.5 1.5 0 0 0 0-3Z"></path></svg>`;
            } else if (message.includes('built bridge')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 8v8m20-8v8M8 4v2m8-2v2M4 12h16"/><path d="M8 10v4m8-4v4"/></svg>`;
            } else {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"/><path d="m9 12 2 2 4-4"/></svg>`;
            }
            return `<div class="log-icon">${iconSvg}</div>`;
        }

        function updateActionLogDisplay() {
            if (!ui.actionLogContent) return;

            ui.actionLogContent.innerHTML = '';
            
            // REMOVED: The reversal of the log array. We now loop through it directly.
            for (const logObject of gameState.actionLog) {
                const originalMessage = logObject.message;
                const activePlayer = logObject.player;

                let formattedMessage = originalMessage.replace(/<br>/g, ' ');

                formattedMessage = formattedMessage.replace(/(P1)/g, '<strong class="p1-log">$1</strong>');
                formattedMessage = formattedMessage.replace(/(P2)/g, '<strong class="p2-log">$1</strong>');
                formattedMessage = formattedMessage.replace(/(\d+)\s(damage|HP)/g, '<strong class="damage-text">$1</strong> $2');
                formattedMessage = formattedMessage.replace(/(healed\s\d+\sHP)/g, '<span class="heal-text">$1</span>');
                formattedMessage = formattedMessage.replace(/(gained a shield)/g, '<span class="shield-text">$1</span>');
                formattedMessage = formattedMessage.replace(/(Advantage!)/g, '<strong class="advantage-text">$1</strong>');
                formattedMessage = formattedMessage.replace(/(Disadvantage!)/g, '<strong class="disadvantage-text">$1</strong>');
                formattedMessage = formattedMessage.replace(/(Spear Wall|Cavalry Screen|Combined arms|Damage split)/g, '<strong class="keyword-text">$1</strong>');

                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-p${activePlayer}`; 
                logEntry.innerHTML = getActionIcon(originalMessage) + `<div class="log-message">${formattedMessage}</div>`;

                ui.actionLogContent.appendChild(logEntry);
            }
        }


                function completeAttack(attackingUnit, targetUnitInfo, attackType) {
            if (!attackingUnit || !targetUnitInfo || attackingUnit.currentMove < ATTACK_COST || attackingUnit.hasPerformedMajorAction) {
                showInstruction("Cannot complete attack.", 2000); 
                resetActionSelectionStates(); 
                updateSelectedUnitInfoPanel(); return;
            }

            let damageModifier = 0;
            let advantageMessage = "";
            let baseDamage = attackingUnit.type.attack;

            if (targetUnitInfo.unit) {
                const attackerType = attackingUnit.type;
                const defenderType = targetUnitInfo.unit.type;
                if (attackerType.strengths && attackerType.strengths.includes(defenderType.name)) {
                    damageModifier = 1;
                    advantageMessage = "Advantage!";
                } else if (attackerType.weaknesses && attackerType.weaknesses.includes(defenderType.name)) {
                    damageModifier = -1;
                    advantageMessage = "Disadvantage!";
                }
            }
            baseDamage += damageModifier;

            let fortifiedArcherMsg = "";
            if (attackType === 'Archer' && attackingUnit.isFortified) { 
                baseDamage += 1; 
                fortifiedArcherMsg = `Fortified Archer +1 Attack.`;
            }
            
            attackingUnit.hasPerformedMajorAction = true;
            let hitAndRunMessage = "";
            if (attackingUnit.type.canMoveAfterAttack) {
                attackingUnit.currentMove -= ATTACK_COST;
                if (isEdgeAdjacentToSpearWall(attackingUnit, attackingUnit.position)) {
                    hitAndRunMessage = "Spear Wall prevents further movement!";
                    gameState.currentReachableMoves.clear();
                } else if (attackingUnit.currentMove > 0) {
                    hitAndRunMessage = "Horseman can move again!";
                    gameState.currentReachableMoves = getPossibleMoves(attackingUnit);
                } else {
                    gameState.currentReachableMoves.clear();
                }
            } else {
                attackingUnit.currentMove = 0;
                gameState.currentReachableMoves.clear();
            }

            let logParts = [];
            if (fortifiedArcherMsg) logParts.push(fortifiedArcherMsg);
            if (advantageMessage) logParts.push(advantageMessage);

            if (targetUnitInfo.isBridgeTarget && targetUnitInfo.edgeKey) {
                const bridgeEdge = gameState.edges.get(targetUnitInfo.edgeKey);
                if (bridgeEdge && bridgeEdge.bridge) {
                    bridgeEdge.bridgeHp -= baseDamage;
                    logParts.push(`P${attackingUnit.player} ${attackingUnit.type.name} targets bridge for ${baseDamage}.<br>Bridge HP: ${bridgeEdge.bridgeHp}/${BRIDGE_MAX_HP}.`);
                    if (bridgeEdge.bridgeHp <= 0) {
                        logParts.push(`Bridge destroyed!`);
                        bridgeEdge.bridge = false; bridgeEdge.bridgeHp = null;
                        [...bridgeEdge.units].forEach(unitOnCollapse => destroyUnit(unitOnCollapse, "bridge_collapse"));
                    }
                } else logParts.push("Target bridge missing.");
            }
            else if (targetUnitInfo.unit) {
                const targetUnit = targetUnitInfo.unit; 
                if (attackingUnit.player !== targetUnit.player) { 
                    targetUnit.lastAttackedByHostileOnTurn = gameState.globalTurnNumber;
                }
                let actualDamage = baseDamage; 
                let defenseMessage = "";
                let pierceMessage = "";

                if (targetUnit.isFortified) {
                    let hasCombinedArmsPartner = false;
                    const edge = gameState.edges.get(attackingUnit.position);
                    if (edge) {
                        if (attackingUnit.type.attackType === 'ranged') hasCombinedArmsPartner = edge.units.some(u => u.id !== attackingUnit.id && u.player === attackingUnit.player && u.type.attackType === 'melee');
                        else if (attackingUnit.type.attackType === 'melee') hasCombinedArmsPartner = edge.units.some(u => u.id !== attackingUnit.id && u.player === attackingUnit.player && u.type.attackType === 'ranged');
                    }
                    if (hasCombinedArmsPartner) {
                        defenseMessage = 'Combined arms negates fortification!';
                    } else {
                        const defenseBonus = targetUnit.type.fortificationBonus || 1;
                        const pierceValue = attackingUnit.type.defenseNegation || 0;
                        if (pierceValue > 0) pierceMessage = `${attackingUnit.type.name} pierces ${pierceValue} defense.`;
                        const effectiveDefense = Math.max(0, defenseBonus - pierceValue);
                        actualDamage = Math.max(0, baseDamage - effectiveDefense);
                        if (effectiveDefense > 0) defenseMessage = `Fortification reduced damage by ${effectiveDefense}.`;
                    }
                }
                if (pierceMessage) logParts.push(pierceMessage);
                if (defenseMessage) logParts.push(defenseMessage);
                
                if (attackType === 'Archer' && targetUnitInfo.edgeKey && actualDamage > 0 && !targetUnit.isFortified) {
                    const edgeOfTarget = gameState.edges.get(targetUnitInfo.edgeKey);
                    const allEnemyUnitsOnEdge = edgeOfTarget ? edgeOfTarget.units.filter(u => u.player === targetUnit.player) : [];
                    if (allEnemyUnitsOnEdge.length === 2) {
                        let splitDamage = Math.max(1, Math.round(actualDamage / 2));
                        logParts.push(`Damage split between 2 units!`);
                        allEnemyUnitsOnEdge.forEach(unitToHit => {
                            unitToHit.hp -= splitDamage;
                            logParts.push(`P${unitToHit.player} ${unitToHit.type.name} takes ${splitDamage} damage. HP: ${unitToHit.hp}`);
                            if (attackingUnit.player !== unitToHit.player) unitToHit.lastAttackedByHostileOnTurn = gameState.globalTurnNumber;
                            if (unitToHit.hp <= 0) destroyUnit(unitToHit);
                        });
                    } else {
                        targetUnit.hp -= actualDamage;
                        logParts.push(`P${attackingUnit.player} ${attackingUnit.type.name} hits P${targetUnit.player} ${targetUnit.type.name} for ${actualDamage}.<br>HP: ${targetUnit.hp}/${targetUnit.maxHp}`);
                        if (targetUnit.hp <= 0) destroyUnit(targetUnit);
                    }
                } else { 
                    targetUnit.hp -= actualDamage;
                    logParts.push(`P${attackingUnit.player} ${attackingUnit.type.name} hits P${targetUnit.player} ${targetUnit.type.name} for ${actualDamage}.<br>HP: ${targetUnit.hp}/${targetUnit.maxHp}`);
                    if (targetUnit.hp <= 0) destroyUnit(targetUnit);
                }
                
                if (targetUnit.type.name === 'Horseman' && attackingUnit.type.attackType === 'melee' && targetUnitInfo.edgeKey) {
                    const edgeOfHorseman = gameState.edges.get(targetUnitInfo.edgeKey);
                    const retaliatingArcher = edgeOfHorseman ? edgeOfHorseman.units.find(u => u.player === targetUnit.player && u.type.name === 'Archer') : null;
                    if (retaliatingArcher) {
                        const retaliationDamage = Math.ceil(retaliatingArcher.type.attack / 2);
                        attackingUnit.hp -= retaliationDamage;
                        logParts.push(`Cavalry Screen! P${retaliatingArcher.player} ${retaliatingArcher.type.name} retaliates for ${retaliationDamage} damage.<br>Attacker HP: ${attackingUnit.hp}/${attackingUnit.maxHp}`);
                        if (attackingUnit.hp <= 0) destroyUnit(attackingUnit, "retaliation");
                    }
                }
            }
            if (hitAndRunMessage) logParts.push(hitAndRunMessage);
            
            logAction(logParts.join('<br>'), gameState.currentPlayer, 4500);

            resetActionSelectionStates(); 
            updateSelectedUnitInfoPanel(); 
            if (!gameState.gameOver) checkVictoryCondition();
        }

        function handleUnitSelectionClick(x, y) {
            let clickedOnUnit = null;
            for (const unit of gameState.units) {
                if (unit.isFortified && unit.positionType === 'center') {
                    const tile = gameState.tiles.get(unit.position);
                    if (tile) {
                        const {x: tileCenterX, y: tileCenterY} = axialToPixel(tile.q, tile.r);
                        if (Math.sqrt((x - tileCenterX)**2 + (y - tileCenterY)**2) < FORTIFIED_UNIT_DRAW_SIZE * 1.5) {
                             if (unit.player === gameState.currentPlayer) { clickedOnUnit = unit; break; }
                             else { showInstruction(`Enemy ${unit.type.name} fortified.`); return true; }
                        }
                    }
                }
            }
            if (!clickedOnUnit) {
                 const unitEdgePairs = [];
                 gameState.edges.forEach((edge, edgeKey) => { edge.units.forEach(u => { if (u.positionType === 'edge') unitEdgePairs.push({ unit: u, edge: edge }); }); });
                for (let i = unitEdgePairs.length - 1; i >= 0; i--) {
                    const {unit, edge} = unitEdgePairs[i]; const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    let unitX = mid.x, unitY = mid.y;
                    const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                    const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                    if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                        const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                        const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                        let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                        let perpX = -dy_val / len, perpY = dx_val / len;
                        unitX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5); unitY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                    }
                    if (Math.sqrt((x - unitX)**2 + (y - unitY)**2) < UNIT_CLICK_RADIUS) {
                       if (unit.player === gameState.currentPlayer) { clickedOnUnit = unit; break; }
                       else { showInstruction(`Enemy ${unit.type.name} on edge.`); return true; }
                    }
                }
            }

            if (clickedOnUnit) {
                if (gameState.selectedUnit && gameState.selectedUnit.id === clickedOnUnit.id) {
                    gameState.selectedUnit = null; 
                    gameState.currentReachableMoves.clear();
                    resetActionSelectionStates(); 
                } else {
                    gameState.selectedUnit = clickedOnUnit;
                    resetActionSelectionStates();
                    
                    const unit = gameState.selectedUnit;
                    const canPhysicallyMove = !unit.isFortified && unit.positionType === 'edge' && unit.currentMove >= 1;
                    const isAllowedToMove = !unit.hasPerformedMajorAction || unit.type.canMoveAfterAttack;

                    if (canPhysicallyMove && isAllowedToMove) {
                        gameState.currentReachableMoves = getPossibleMoves(unit);
                    } else {
                        gameState.currentReachableMoves.clear();
                    }
                }
                updateSelectedUnitInfoPanel(); 
                return true;
            }
            return false;
        }

        function handleMoveAction(unitToMove, targetEdgeKey, costToMove) {
             if (unitToMove.positionType === 'edge') {
                const oldEdge = gameState.edges.get(unitToMove.position);
                if (oldEdge) oldEdge.units = oldEdge.units.filter(u => u.id !== unitToMove.id);
            }
            const finalTargetEdgeData = gameState.edges.get(targetEdgeKey);
             if (!finalTargetEdgeData) { console.error("Target edge for move not found:", targetEdgeKey); return; }
            unitToMove.position = targetEdgeKey; unitToMove.positionType = 'edge'; unitToMove.currentMove -= costToMove;
            finalTargetEdgeData.units.push(unitToMove);

            const unitDestroyedByZoC = applyFortificationDamageOnMove(unitToMove, targetEdgeKey);
            clearDebugPath();
            if (!unitDestroyedByZoC && unitToMove.hp > 0) {
                logAction(`${unitToMove.type.name} moved. MP: ${Math.floor(unitToMove.currentMove)}`, gameState.currentPlayer);
                if (unitToMove.currentMove >= 1 && (!unitToMove.hasPerformedMajorAction || unitToMove.type.canMoveAfterAttack)) {
                    gameState.currentReachableMoves = getPossibleMoves(unitToMove);
                } else {
                    gameState.currentReachableMoves.clear();
                }
                gameState.selectedUnit = unitToMove; 
            } else {
                 gameState.currentReachableMoves.clear();
                 if (gameState.selectedUnit && gameState.selectedUnit.id === unitToMove.id) gameState.selectedUnit = null;
            }
            
            const enemyFlag = unitToMove.player === 1 ? gameState.flags.p2_flag : gameState.flags.p1_flag;
            if (enemyFlag.status === 'at_base' && targetEdgeKey === enemyFlag.homePosition) {
                enemyFlag.status = 'carried';
                enemyFlag.carrierId = unitToMove.id;
                unitToMove.isCarryingFlag = true;
                unitToMove.currentMove = 0;
                logAction(`P${unitToMove.player} ${unitToMove.type.name} has picked up the flag!`, gameState.currentPlayer);
                updateAllHealingStatus();
                severSupplyLinesForPlayer(enemyFlag.player); // NEW: Sever supply lines for the flag's owner.
            }

            updateSelectedUnitInfoPanel(); 
            checkVictoryCondition();


        }

        function handleMoveClick(x, y) {
            const { selectedUnit } = gameState;
            if (!selectedUnit || selectedUnit.isFortified || selectedUnit.currentMove < 1) {
                return false;
            }
            if (selectedUnit.hasPerformedMajorAction && !selectedUnit.type.canMoveAfterAttack) {
                return false;
            }
            for (const [targetEdgeKey, moveData] of gameState.currentReachableMoves) {
                const finalTargetEdgeData = gameState.edges.get(targetEdgeKey); if (!finalTargetEdgeData) continue;
                const mid = getEdgeMidpoint(finalTargetEdgeData.q1, finalTargetEdgeData.r1, finalTargetEdgeData.q2, finalTargetEdgeData.r2);
                if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < HIGHLIGHT_CLICK_RADIUS) {
                    const costToMove = moveData.cost;
                    if (finalTargetEdgeData.units.some(u => u.player !== selectedUnit.player)) { showInstruction("Cannot move to enemy edge."); return true; }
                    if (finalTargetEdgeData.units.filter(u => u.player === selectedUnit.player).length >= 2) { showInstruction("Target edge full."); return true; }
                    if (costToMove <= selectedUnit.currentMove && costToMove !== Infinity) handleMoveAction(selectedUnit, targetEdgeKey, costToMove);
                    else showInstruction(`Cannot move. Cost: ${costToMove.toFixed(1)}, Have: ${selectedUnit.currentMove.toFixed(1)}`);
                    return true;
                }
            }
             return false;
        }

        function handleActionTargetSelectionClick(x, y) {
            const { selectedUnit, currentActionState } = gameState;
            if (!selectedUnit) return false;

            let clickHandled = true;
            let clickedValidTarget = false;

            switch (currentActionState) {
                case ACTION_STATES.SELECTING_FORTIFY_TILE:
                    const clickedAxial = pixelToAxial(x, y);
                    const clickedTileKey = getTileKey(clickedAxial.q, clickedAxial.r);
                    if (gameState.validFortifyTargetTileKeys.includes(clickedTileKey)) {
                        completeFortify(clickedTileKey);
                        clickedValidTarget = true;
                    }
                    break;

                case ACTION_STATES.SELECTING_UNFORTIFY_EDGE:
                    for (const edgeKey of gameState.validUnfortifyTargetEdgeKeys) {
                        const edge = gameState.edges.get(edgeKey);
                        if (edge) {
                            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                            if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < HIGHLIGHT_CLICK_RADIUS) {
                                completeUnfortify(edgeKey);
                                clickedValidTarget = true;
                                break;
                            }
                        }
                    }
                    break;

                case ACTION_STATES.SELECTING_BRIDGE_EDGE:
                    for (const edgeKey of gameState.validBridgeTargetEdgeKeys) {
                        const edge = gameState.edges.get(edgeKey);
                        if (edge) {
                            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                            if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < HIGHLIGHT_CLICK_RADIUS) {
                                completeBuildBridge(edgeKey);
                                clickedValidTarget = true;
                                break;
                            }
                        }
                    }
                    break;
                
                case ACTION_STATES.SELECTING_ATTACK_TARGET:
                    const currentAttackTargets = selectedUnit.type.attackType === 'melee' 
                        ? gameState.validMeleeAttackTargets 
                        : gameState.validArcherAttackTargets;
                    const attackType = selectedUnit.type.attackType === 'melee' ? 'Melee' : 'Archer';

                    for (const targetInfo of currentAttackTargets) {
                        if (targetInfo.isBridgeTarget && targetInfo.edgeKey) {
                            const edge = gameState.edges.get(targetInfo.edgeKey);
                            if (edge && edge.bridge) {
                                const p = { x, y };
                                const p1_center = axialToPixel(edge.q1, edge.r1); const p2_center = axialToPixel(edge.q2, edge.r2);
                                const edgeMidX = (p1_center.x + p2_center.x) / 2; const edgeMidY = (p1_center.y + p2_center.y) / 2;
                                let perp_dx = -(p2_center.y - p1_center.y); let perp_dy = p2_center.x - p1_center.x;
                                const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);

                                if (len_perp_vec > 0) {
                                    const scale = HEX_SIZE / 2;
                                    perp_dx = (perp_dx / len_perp_vec) * scale;
                                    perp_dy = (perp_dy / len_perp_vec) * scale;
                                    const v = { x: edgeMidX + perp_dx, y: edgeMidY + perp_dy };
                                    const w = { x: edgeMidX - perp_dx, y: edgeMidY - perp_dy };

                                    if (distToSegmentSquared(p, v, w) < (BRIDGE_CLICK_TOLERANCE * 2)**2) {
                                        completeAttack(selectedUnit, targetInfo, attackType);
                                        clickedValidTarget = true;
                                        break;
                                    }
                                }
                            }
                        } else if (targetInfo.unit) {
                            const targetUnit = targetInfo.unit; let unitX_val, unitY_val, clickRadius = UNIT_CLICK_RADIUS;
                            if (targetUnit.isFortified && targetUnit.positionType === 'center' && targetInfo.tileKeyForTarget) {
                                const tile = gameState.tiles.get(targetInfo.tileKeyForTarget);
                                if (tile) { const centerPixel = axialToPixel(tile.q, tile.r); unitX_val = centerPixel.x; unitY_val = centerPixel.y; clickRadius = FORTIFIED_UNIT_DRAW_SIZE * 1.5; }
                                else continue;
                            } else if (targetInfo.edgeKey) {
                                const edgeOfTarget = gameState.edges.get(targetInfo.edgeKey); if (!edgeOfTarget) continue;
                                const mid = getEdgeMidpoint(edgeOfTarget.q1, edgeOfTarget.r1, edgeOfTarget.q2, edgeOfTarget.r2); unitX_val = mid.x; unitY_val = mid.y;
                                const edgeUnitsOnly = edgeOfTarget.units.filter(u => u.positionType === 'edge');
                                const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === targetUnit.id);
                                if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                                    const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                                    const p1 = axialToPixel(edgeOfTarget.q1, edgeOfTarget.r1); const p2 = axialToPixel(edgeOfTarget.q2, edgeOfTarget.r2);
                                    let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                                    let perpX = -dy_val / len, perpY = dx_val / len;
                                    unitX_val += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5); unitY_val += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                                }
                            } else continue;
                            if (Math.sqrt((x - unitX_val)**2 + (y - unitY_val)**2) < clickRadius) { 
                                completeAttack(selectedUnit, targetInfo, attackType); 
                                clickedValidTarget = true; 
                                break; 
                            }
                        }
                    }
                    if (clickedValidTarget) break; 
                    break; 

                default:
                    clickHandled = false;
                    break;
            }

            if (clickHandled && !clickedValidTarget) {
                showInstruction("Invalid selection. Click a highlighted target or Cancel.", 2000);
            }
            return clickHandled;
        }

        // --- REFACTORED GENERIC EVENT HANDLERS ---
        function handleInteractionStart(x, y, isTouchEvent = false) {
            if (gameState.gameOver || gameState.currentActionState !== ACTION_STATES.IDLE && gameState.currentActionState !== ACTION_STATES.UNIT_SELECTED) return;

            dragOperationJustConcluded = false; 
            clearDebugPath();
            
            gameState.dragStartX = x; 
            gameState.dragStartY = y; 
            gameState.draggedDistance = 0;

            let unitToDrag = null;
            const clickRadius = isTouchEvent ? UNIT_CLICK_RADIUS * 1.5 : UNIT_CLICK_RADIUS;
            const edgeUnits = [];
            gameState.edges.forEach(edge => edge.units.forEach(u => { if (u.positionType === 'edge') edgeUnits.push({unit:u, edge}); }));
            
            for (let i = edgeUnits.length - 1; i >= 0; i--) {
                 const {unit, edge} = edgeUnits[i];
                 if (unit.player !== gameState.currentPlayer || unit.isFortified || unit.currentMove < 1) continue;
                 if (unit.hasPerformedMajorAction && !unit.type.canMoveAfterAttack) continue;
                 
                 const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                 let unitCenterX = mid.x, unitCenterY = mid.y;
                 const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                 const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                 if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                    const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                    const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                    let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                    let perpX = -dy_val / len, perpY = dx_val / len;
                    unitCenterX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5); unitCenterY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                 }
                 if (Math.sqrt((x - unitCenterX)**2 + (y - unitCenterY)**2) < clickRadius) { 
                     unitToDrag = unit; 
                     break; 
                 }
            }

            if (unitToDrag) {
                gameState.isDragging = true; 
                gameState.draggingUnit = unitToDrag;
                gameState.dragUnitOriginalPosition = unitToDrag.position; 
                gameState.dragUnitOriginalType = unitToDrag.positionType;
                gameState.dragUnitRenderX = x; 
                gameState.dragUnitRenderY = y;
                
                if (!gameState.selectedUnit || gameState.selectedUnit.id !== unitToDrag.id) {
                    gameState.selectedUnit = unitToDrag;
                    gameState.currentActionState = ACTION_STATES.UNIT_SELECTED;
                    updateSelectedUnitInfoPanel();
                }
                
                gameState.currentReachableMoves = getPossibleMoves(unitToDrag);
                
                if (unitToDrag.positionType === 'edge') {
                    const edgeData = gameState.edges.get(unitToDrag.position);
                    if (edgeData) edgeData.units = edgeData.units.filter(u => u.id !== unitToDrag.id);
                }
                canvas.style.cursor = 'grabbing'; 
            }
        }
        
        function handleInteractionMove(x, y) {
             if (gameState.isDragging && gameState.draggingUnit) {
                gameState.dragUnitRenderX = x; 
                gameState.dragUnitRenderY = y;
                gameState.draggedDistance = Math.sqrt((x - gameState.dragStartX)**2 + (y - gameState.dragStartY)**2);
                
                let foundPathUnderCursor = null;
                for (const [targetEdgeKey, moveData] of gameState.currentReachableMoves) {
                     const finalTargetEdgeData = gameState.edges.get(targetEdgeKey); if (!finalTargetEdgeData) continue;
                     const mid = getEdgeMidpoint(finalTargetEdgeData.q1, finalTargetEdgeData.r1, finalTargetEdgeData.q2, finalTargetEdgeData.r2);
                     if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < HIGHLIGHT_CLICK_RADIUS) { 
                        foundPathUnderCursor = moveData.path; 
                        break; 
                    }
                 }

                if (foundPathUnderCursor) {
                    const newPotentialPathKey = foundPathUnderCursor.join('-');
                    const currentPotentialPathKey = gameState.potentialDebugPathToDraw ? gameState.potentialDebugPathToDraw.join('-') : null;

                    if (newPotentialPathKey !== currentPotentialPathKey) {
                        gameState.potentialDebugPathToDraw = foundPathUnderCursor;
                        gameState.debugPathHoverStartTime = Date.now();
                        if (gameState.debugPathToDraw && gameState.debugPathToDraw.join('-') !== newPotentialPathKey) {
                            clearDebugPath(); 
                        }
                    }
                } else { 
                    if (gameState.potentialDebugPathToDraw) {
                       clearDebugPath(); 
                    }
                }
            }
        }

        function handleInteractionEnd(x, y, isTouchEvent = false) {
            if (!gameState.isDragging || !gameState.draggingUnit) return;
            
            dragOperationJustConcluded = true;
            let droppedOnValidTarget = false;
            
            if (gameState.draggedDistance >= DRAGGED_DISTANCE_THRESHOLD) {
                const dropRadius = isTouchEvent ? HIGHLIGHT_CLICK_RADIUS * 1.2 : HIGHLIGHT_CLICK_RADIUS;
                for (const [targetEdgeKey, moveData] of gameState.currentReachableMoves) {
                    const finalTargetEdgeData = gameState.edges.get(targetEdgeKey); if (!finalTargetEdgeData) continue;
                    const mid = getEdgeMidpoint(finalTargetEdgeData.q1, finalTargetEdgeData.r1, finalTargetEdgeData.q2, finalTargetEdgeData.r2);
                    if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < dropRadius) {
                        const costToMove = moveData.cost; 
                        if (finalTargetEdgeData.units.some(u => u.player !== gameState.draggingUnit.player)) { showInstruction("Cannot move to enemy edge."); break; }
                        if (finalTargetEdgeData.units.filter(u => u.player === gameState.draggingUnit.player).length >= 2) { showInstruction("Target edge full."); break; }
                        if (costToMove <= gameState.draggingUnit.currentMove && costToMove !== Infinity) { 
                            handleMoveAction(gameState.draggingUnit, targetEdgeKey, costToMove); 
                            droppedOnValidTarget = true; 
                        }
                        else { showInstruction(`Cannot move. Cost: ${costToMove.toFixed(1)}, Have: ${gameState.draggingUnit.currentMove.toFixed(1)}`); }
                        break;
                    }
                }
            }
            
            if (!droppedOnValidTarget) {
                 const unit = gameState.draggingUnit;
                if (unit) {
                    if (gameState.dragUnitOriginalType === 'edge' && gameState.dragUnitOriginalPosition) {
                         const originalEdge = gameState.edges.get(gameState.dragUnitOriginalPosition);
                         if (originalEdge && !originalEdge.units.find(u => u.id === unit.id)) originalEdge.units.push(unit);
                         unit.position = gameState.dragUnitOriginalPosition; unit.positionType = 'edge';
                     }
                     if (gameState.draggedDistance >= DRAGGED_DISTANCE_THRESHOLD) showInstruction("Invalid drop. Unit returned.", 2000);
                     gameState.selectedUnit = unit;
                     gameState.currentActionState = ACTION_STATES.UNIT_SELECTED; 
                      if(unit && !unit.isFortified && unit.hp > 0 && !unit.hasPerformedMajorAction && unit.currentMove >=1) gameState.currentReachableMoves = getPossibleMoves(unit);
                      else gameState.currentReachableMoves.clear();
                }
            }
            
            gameState.isDragging = false; 
            gameState.draggingUnit = null; 
            gameState.dragUnitOriginalPosition = null; 
            gameState.dragUnitOriginalType = null;
            clearDebugPath(); 
            canvas.style.cursor = gameState.hoveredUnitId ? 'pointer' : 'default'; 
            updateSelectedUnitInfoPanel(); 
        }

        function handleInteractionCancel() {
            dragOperationJustConcluded = true;
            clearDebugPath();
            if (gameState.isDragging && gameState.draggingUnit) {
                 const unit = gameState.draggingUnit;
                 if (gameState.dragUnitOriginalType === 'edge' && gameState.dragUnitOriginalPosition) {
                     const originalEdge = gameState.edges.get(gameState.dragUnitOriginalPosition);
                     if (originalEdge && !originalEdge.units.find(u => u.id === unit.id)) originalEdge.units.push(unit);
                     unit.position = gameState.dragUnitOriginalPosition; unit.positionType = 'edge';
                 }
                gameState.isDragging = false; 
                gameState.draggingUnit = null; 
                gameState.dragUnitOriginalPosition = null; 
                gameState.dragUnitOriginalType = null;
                showInstruction("Drag cancelled. Unit returned.", 2500);
                gameState.selectedUnit = unit; 
                gameState.currentActionState = ACTION_STATES.UNIT_SELECTED;
                if(unit && !unit.isFortified && unit.hp > 0 && !unit.hasPerformedMajorAction && unit.currentMove >=1) gameState.currentReachableMoves = getPossibleMoves(unit);
                else gameState.currentReachableMoves.clear();
                updateSelectedUnitInfoPanel();
            }
        }
        
        function handleTapLogic(x, y) {
            if (handleActionTargetSelectionClick(x, y)) { /* Action target click handled */ } 
            else if (handleUnitSelectionClick(x,y)) { /* Unit selection/deselection handled */ }
            else if (handleMoveClick(x, y)) { /* Click-to-move handled */ } 
            else if (gameState.selectedUnit) {
                 gameState.selectedUnit = null; 
                 gameState.currentReachableMoves.clear();
                 resetActionSelectionStates(); 
                 updateSelectedUnitInfoPanel(); 
            }
        }

        // --- Original Event Handlers (Now as Wrappers) ---
        function handleCanvasMouseDown(event) {
            if (event.button !== 0) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handleInteractionStart(x, y, false);
        }

        function handleCanvasMouseMove(event) {
            if (gameState.gameOver) return;
            const rect = canvas.getBoundingClientRect(); 
            const x = event.clientX - rect.left; 
            const y = event.clientY - rect.top;

            if (gameState.isDragging) {
                event.preventDefault();
                handleInteractionMove(x, y);
            } else {
                let foundHoverable = false; let newHoveredUnitId = null; const edgeUnits = [];
                gameState.edges.forEach(edge => edge.units.forEach(u => { if (u.positionType === 'edge') edgeUnits.push({unit:u, edge}); }));
                for(let i = edgeUnits.length -1; i >= 0; i--) {
                    const {unit, edge} = edgeUnits[i]; if (unit.player !== gameState.currentPlayer) continue;
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    let unitCenterX = mid.x, unitCenterY = mid.y;
                    const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                    const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                    if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                        const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                        const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                        let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                        let perpX = -dy_val / len, perpY = dx_val / len;
                        unitCenterX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5); unitCenterY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                    }
                    if (Math.sqrt((x - unitCenterX)**2 + (y - unitCenterY)**2) < UNIT_CLICK_RADIUS) { newHoveredUnitId = unit.id; foundHoverable = true; break; }
                }
                 if (!foundHoverable) {
                     for (const unit of gameState.units) {
                         if (unit.isFortified && unit.positionType === 'center' && unit.player === gameState.currentPlayer) {
                             const tile = gameState.tiles.get(unit.position);
                             if (tile) {
                                 const {x: tileCenterX, y: tileCenterY} = axialToPixel(tile.q, tile.r);
                                 if (Math.sqrt((x - tileCenterX)**2 + (y - tileCenterY)**2) < FORTIFIED_UNIT_DRAW_SIZE * 1.5) { newHoveredUnitId = unit.id; foundHoverable = true; break; }
                             }
                         }
                     }
                 }
                if (gameState.hoveredUnitId !== newHoveredUnitId) gameState.hoveredUnitId = newHoveredUnitId;
                canvas.style.cursor = foundHoverable ? 'pointer' : 'default';
            }
        }

        function handleCanvasMouseUp(event) {
            if (gameState.gameOver || !gameState.isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handleInteractionEnd(x, y, false);
        }

        function handleCanvasMouseLeave(event) {
            handleInteractionCancel();
            if (gameState.hoveredUnitId !== null) gameState.hoveredUnitId = null;
            canvas.style.cursor = 'default';
        }

        function handleCanvasTouchStart(event) {
            if (gameState.gameOver || event.touches.length !== 1) return;
            event.preventDefault();
            const touch = event.touches[0]; 
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            handleInteractionStart(x, y, true);
        }

        function handleCanvasTouchMove(event) {
            if (gameState.isDragging && gameState.draggingUnit && event.touches.length === 1) {
                event.preventDefault();
                const touch = event.touches[0]; 
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                handleInteractionMove(x, y);
            }
        }

        function handleCanvasTouchEnd(event) {
            if (gameState.gameOver) return;
            const finalTouch = event.changedTouches[0]; 
            if (!finalTouch) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = finalTouch.clientX - rect.left;
            const y = finalTouch.clientY - rect.top;

            const wasDragging = gameState.isDragging;
            const wasShortDrag = gameState.draggedDistance < DRAGGED_DISTANCE_THRESHOLD;

            if (wasDragging) {
                handleInteractionEnd(x, y, true);
            }
            
            if (!wasDragging || wasShortDrag) {
                handleTapLogic(x, y);
            }
            
            gameState.draggedDistance = 0;
            updateSelectedUnitInfoPanel();
        }

        function handleCanvasTouchCancel(event) {
            handleInteractionCancel();
            gameState.draggedDistance = 0;
        }

        function handleCanvasClick(event) {
            if (gameState.gameOver || event.button !== 0) return;
            if (dragOperationJustConcluded) { 
                dragOperationJustConcluded = false; 
                return; 
            }
            const rect = canvas.getBoundingClientRect(); 
            const x = event.clientX - rect.left; 
            const y = event.clientY - rect.top;
            handleTapLogic(x, y);
        }

        // --- Zone of Control Damage & Healing ---
        function applyStartOfTurnZoCDamage() {
            const activePlayer = gameState.currentPlayer;
            const enemyPlayer = activePlayer === 1 ? 2 : 1;
            let unitsToDestroy = [];

            // Get the active player's base camp tiles to apply damage to the enemy
            const activePlayerBaseEdgeKey = FLAG_HOME_POSITIONS[`player${activePlayer}`];
            const activePlayerBaseTiles = [activePlayerBaseEdgeKey.split('_')[0], activePlayerBaseEdgeKey.split('_')[1]];

            gameState.units.forEach(unit => {
                // We are checking for enemy units adjacent to the current player's forts/base
                if (unit.player !== enemyPlayer || unit.positionType !== 'edge' || unit.isFortified) return;
                
                const edgeKey = unit.position;
                const edgeTileCoords = parseEdgeKey(edgeKey);
                if (edgeTileCoords.some(coord => isNaN(coord.q))) return;
        
                const tile1Key = getTileKey(edgeTileCoords[0].q, edgeTileCoords[0].r);
                const tile2Key = getTileKey(edgeTileCoords[1].q, edgeTileCoords[1].r);
                const tile1 = gameState.tiles.get(tile1Key);
                const tile2 = gameState.tiles.get(tile2Key);
                
                // Check for damage from a standard fort OR from the active player's base camp fort effect
                if ((tile1 && tile1.fortifiedByPlayer === activePlayer) || 
                    (tile2 && tile2.fortifiedByPlayer === activePlayer) ||
                    activePlayerBaseTiles.includes(tile1Key) || 
                    activePlayerBaseTiles.includes(tile2Key)) 
                {
                    unit.hp -= FORTIFICATION_DAMAGE;
                    // Correctly log that the action happened during the ACTIVE player's turn
                    logAction(`P${unit.player} ${unit.type.name} takes start-of-turn ZoC. HP: ${unit.hp}`, activePlayer, 3500);
                    if (unit.hp <= 0 && !unitsToDestroy.find(u => u.id === unit.id)) {
                        unitsToDestroy.push(unit);
                    }
                }
            });

            if (unitsToDestroy.length > 0) unitsToDestroy.forEach(u => destroyUnit(u, "zoc_turn_start"));
        }

        function updateAllHealingStatus() {
            // Check flag status for both players
            const p1FlagStolen = gameState.flags.p1_flag.status === 'carried';
            const p2FlagStolen = gameState.flags.p2_flag.status === 'carried';

            gameState.units.forEach(unit => {
                if (unit.isFortified) {
                    if (unit.player === 1) {
                        unit.canHeal = !p1FlagStolen;
                    } else { // unit.player === 2
                        unit.canHeal = !p2FlagStolen;
                    }
                } else {
                    unit.canHeal = false; // Unfortified units can't heal anyway
                }
            });
            // Let players know what happened
            if (p1FlagStolen) { logAction(`P1's flag is stolen! Healing is disabled.`, 2, 3000); }
            if (p2FlagStolen) { logAction(`P2's flag is stolen! Healing is disabled.`, 1, 3000); }
        }

        function applyStartOfTurnHealing() {
            const playerFlag = gameState.flags[`p${gameState.currentPlayer}_flag`];
            if (playerFlag.status === 'carried') {
                return; // No healing for anyone if their flag is stolen.
            }

            gameState.units.forEach(unit => {
                if (unit.player !== gameState.currentPlayer || !unit.isFortified || unit.hp >= (unit.maxHp + 1)) {
                    return;
                }

                const recentlyAttacked = gameState.globalTurnNumber < unit.lastAttackedByHostileOnTurn + 2;
                if (recentlyAttacked) {
                    return;
                }
                
                let isSupplied = false;
                const playerBaseTiles = [FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[0], FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[1]];
                
                if (playerBaseTiles.includes(unit.fortifiedTileKey)) {
                    isSupplied = true;
                } else if (unit.supplyLine && unit.supplyLine.path) {
                    const isIntercepted = unit.supplyLine.path.some(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        return edge && edge.units.some(u => u.player !== unit.player);
                    });
                    if (!isIntercepted) {
                        isSupplied = true;
                    }
                }

                if (isSupplied) {
                    const oldHp = unit.hp;
                    unit.hp++;
                    const activePlayer = gameState.currentPlayer;
                    if (oldHp < unit.maxHp && unit.hp === unit.maxHp) {
                        logAction(`P${unit.player} ${unit.type.name} healed to full HP.`, activePlayer, 2500);
                    } else if (unit.hp === unit.maxHp + 1) {
                        logAction(`P${unit.player} ${unit.type.name} gained a shield!`, activePlayer, 2500);
                    } else {
                         logAction(`P${unit.player} ${unit.type.name} healed 1 HP.`, activePlayer, 2500);
                    }
                }
            });
        }

        function logSiegeStatus() {
            const activePlayer = gameState.currentPlayer;
            const playerFlag = gameState.flags[`p${activePlayer}_flag`];

            if (playerFlag.status === 'carried') {
                const existingLog = gameState.actionLog[gameState.actionLog.length - 1];
                if (!existingLog || !existingLog.message.includes('Healing is disabled')) {
                    logAction(`P${activePlayer}'s flag is stolen! All healing is disabled.`, activePlayer);
                }
            }

            gameState.units.forEach(unit => {
                if (unit.player === activePlayer && unit.isFortified && unit.supplyLine && unit.supplyLine.path) {
                    const isIntercepted = unit.supplyLine.path.some(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        return edge && edge.units.some(u => u.player !== unit.player);
                    });

                    if (isIntercepted) {
                         logAction(`P${unit.player} ${unit.type.name} is under siege and cannot heal!`, activePlayer);
                    }
                }
            });
        }

        function handleRespawnQueue() {
            const player = gameState.currentPlayer;
            const queueKey = `player${player}`;
            const queue = gameState.respawnQueue[queueKey];
            
            if (queue.length === 0) {
                return;
            }

            const firstItem = queue[0];
            firstItem.turnsRemaining--;

            if (firstItem.turnsRemaining <= 0) {
                showRespawnModal(player);
            }
            
            updateRespawnQueueDisplay();
        }

        // --- Game Flow & Event Listeners ---
        function checkVictoryCondition() {
            if (gameState.gameOver) return;
            let victoryText = null;

            const flagCarrier = gameState.units.find(u => u.isCarryingFlag);
            if (flagCarrier) {
                const carrierPlayer = flagCarrier.player;
                const carrierHomeBaseEdge = FLAG_HOME_POSITIONS[`player${carrierPlayer}`];

                if (flagCarrier.position === carrierHomeBaseEdge) {
                    victoryText = `Player ${carrierPlayer} captured the flag and wins!`;
                }
            }
            
            if (!victoryText) {
                const player1Units = gameState.units.filter(u => u.player === 1);
                const player2Units = gameState.units.filter(u => u.player === 2);
                
                if (gameState.tiles.size > 0) { 
                    if (player1Units.length === 0 && player2Units.length > 0) {
                        victoryText = "Player 2 Wins by Annihilation!";
                    } else if (player2Units.length === 0 && player1Units.length > 0) {
                        victoryText = "Player 1 Wins by Annihilation!";
                    } else if (player1Units.length === 0 && player2Units.length === 0) {
                        victoryText = "It's a Draw!";
                    }
                }
            }

            if (victoryText) {
                ui.victoryMessage.textContent = victoryText;
                ui.victoryMessage.style.display = 'block';
                gameState.gameOver = true;
                gameState.currentActionState = ACTION_STATES.IDLE;
                ui.endTurnButton.disabled = true;
                ui.generateMapButton.disabled = false; 
                if (gameState.selectedUnit) {
                    ui.fortifyUnfortifyButton.disabled = true;
                    ui.buildBridgeButton.disabled = true;
                    ui.attackButton.disabled = true;
                } else {
                    ui.actionsPanel.style.display = 'none';
                }
                canvas.style.cursor = 'default'; 
                gameState.selectedUnit = null;
                gameState.currentReachableMoves.clear(); 
                updateSelectedUnitInfoPanel(); 
            } else {
                ui.generateMapButton.disabled = false;
            }
        }                                                                           

        ui.fortifyUnfortifyButton.addEventListener('click', handleFortifyUnfortifyButtonClick);
        ui.buildBridgeButton.addEventListener('click', handleBuildBridgeAction);
        ui.attackButton.addEventListener('click', handleAttackAction);

        ui.endTurnButton.addEventListener('click', () => {
            if (gameState.isDragging || gameState.gameOver) return;
            
            const previousPlayer = gameState.currentPlayer;
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;

            if (previousPlayer === 2 && gameState.currentPlayer === 1) { 
                gameState.globalTurnNumber++;
                updateGlobalTurnDisplay();
            }
            
            gameState.selectedUnit = null; 
            gameState.currentReachableMoves.clear();
            gameState.hoveredUnitId = null; 
            canvas.style.cursor = 'default';
            resetActionSelectionStates();
            
            gameState.units.forEach(unit => {
                if (unit.player === gameState.currentPlayer) {
                    unit.hasPerformedMajorAction = false; 
                    
                    let baseMoveForTurn = unit.type.baseMove;
                    if (unit.isCarryingFlag) {
                        baseMoveForTurn -= 1; 
                    }
                    unit.currentMove = Math.max(0, baseMoveForTurn); 
                    
                    // --- Handle Cowardice Timer ---
                    const playerBaseTiles = [FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[0], FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[1]];
                    if (unit.isFortified && playerBaseTiles.includes(unit.fortifiedTileKey)) {
                        unit.turnsFortifiedAtBase++;
                        if (unit.turnsFortifiedAtBase > MAX_BASE_CAMP_TURNS) {
                            logAction(`P${unit.player} ${unit.type.name} was destroyed for cowardice!`, gameState.currentPlayer);
                            destroyUnit(unit, "cowardice");
                        }
                    }
                }
            });
            
            handleRespawnQueue();

            applyStartOfTurnZoCDamage(); 
            logSiegeStatus();
            applyStartOfTurnHealing(); 
            
            updateTurnDisplay();
            updateSelectedUnitInfoPanel(); 
            
            showInstruction(`Player ${gameState.currentPlayer}'s turn.`);
            logAction(`Player ${gameState.currentPlayer}'s Turn Begins`, gameState.currentPlayer);
            checkVictoryCondition();
        });

        ui.generateMapButton.addEventListener('click', () => {
            if (gameState.isDragging) return; 
            if (ui.customConfirmModal) {
                ui.customConfirmModal.style.display = 'flex';
                setTimeout(() => ui.customConfirmModal.classList.add('modal-visible'), 10);
            }
        });
        ui.customConfirmOkButton.addEventListener('click', () => {
            if (ui.customConfirmModal) {
                ui.customConfirmModal.classList.remove('modal-visible');
                setTimeout(() => ui.customConfirmModal.style.display = 'none', 300); 
            }
            handleGenerateNewMap();
        });
        ui.customConfirmCancelButton.addEventListener('click', () => {
             if (ui.customConfirmModal) {
                ui.customConfirmModal.classList.remove('modal-visible');
                setTimeout(() => ui.customConfirmModal.style.display = 'none', 300); 
            }
        });


        function handleGenerateNewMap() {
             gameState.isDragging = false; 
             gameState.draggingUnit = null;
            const newLayout = generateTileLayout(gameState.gridRadius);
            initializeGrid(newLayout); 
            showInstruction("New map generated. Player 1's Turn.", 3000);
        }

        function generateTileLayout(radius) {
            const tempTiles = new Map();
            const allHexCoords = [];
            for (let q = -radius; q <= radius; q++) {
                for (let r = -radius; r <= radius; r++) {
                    if (Math.abs(q + r) <= radius) {
                        allHexCoords.push({ q, r });
                        tempTiles.set(getTileKey(q, r), null); 
                    }
                }
            }
            allHexCoords.sort(() => 0.5 - Math.random()); 

            let counts = { MOUNTAIN: 0, WATER: 0, FOREST: 0, PLAINS: 0 };
            const tileBudget = {
                MOUNTAIN: MAX_MOUNTAIN_TILES_TOTAL,
                WATER: MAX_WATER_TILES_TOTAL,
                FOREST: MAX_FOREST_TILES_TOTAL,
                PLAINS: MAX_PLAINS_TILES_TOTAL
            };

            function assignTile(q, r, type, currentCounts) {
                const key = getTileKey(q, r);
                const oldType = tempTiles.get(key);
                if (oldType) { 
                    const oldTypeName = oldType.name.toUpperCase();
                    if (currentCounts.hasOwnProperty(oldTypeName)) currentCounts[oldTypeName]--;
                }
                tempTiles.set(key, type);
                const newTypeName = type.name.toUpperCase();
                if (currentCounts.hasOwnProperty(newTypeName)) currentCounts[newTypeName]++;
            }
            
            allHexCoords.forEach(coord => {
                const key = getTileKey(coord.q, coord.r);
                if (tempTiles.get(key) !== null) return; 

                if (counts.MOUNTAIN < tileBudget.MOUNTAIN && axialDistance(coord.q, coord.r, 0, 0) > 1) {
                    let adjacentMountains = 0;
                    getNeighbors(coord.q,coord.r).forEach(n => {
                        const nKey = getTileKey(n.q,n.r);
                        if(tempTiles.has(nKey) && tempTiles.get(nKey) === TILE_TYPES.MOUNTAIN) adjacentMountains++;
                    });
                    if (adjacentMountains < MAX_MOUNTAIN_TILES_PER_CLUSTER) {
                        if (Math.random() < MOUNTAIN_SPAWN_CHANCE) {
                            assignTile(coord.q, coord.r, TILE_TYPES.MOUNTAIN, counts);
                            return; 
                        }
                    }
                }
            });
             allHexCoords.forEach(coord => { 
                const key = getTileKey(coord.q, coord.r);
                if (tempTiles.get(key) !== null) return;

                if (counts.WATER < tileBudget.WATER && Math.random() < WATER_SPAWN_CHANCE) {
                     assignTile(coord.q, coord.r, TILE_TYPES.WATER, counts);
                     return;
                }
            });
            allHexCoords.forEach(coord => { 
                const key = getTileKey(coord.q, coord.r);
                if (tempTiles.get(key) !== null) return;
                if (counts.FOREST < tileBudget.FOREST && Math.random() < FOREST_SPAWN_CHANCE) {
                    assignTile(coord.q, coord.r, TILE_TYPES.FOREST, counts);
                    return;
                }
            });

            allHexCoords.forEach(coord => {
                if (tempTiles.get(getTileKey(coord.q, coord.r)) === null) {
                    assignTile(coord.q, coord.r, TILE_TYPES.PLAINS, counts);
                }
            });

            const adjustmentPasses = 3; 
            for (let pass = 0; pass < adjustmentPasses; pass++) {
                allHexCoords.sort(() => 0.5 - Math.random()); 

                if (counts.WATER < MIN_WATER_TILES_SOFT && counts.WATER < tileBudget.WATER) {
                    for (const coord of allHexCoords) {
                        if (counts.WATER >= MIN_WATER_TILES_SOFT || counts.WATER >= tileBudget.WATER) break;
                        const key = getTileKey(coord.q, coord.r);
                        if (tempTiles.get(key) === TILE_TYPES.PLAINS) { 
                            assignTile(coord.q, coord.r, TILE_TYPES.WATER, counts);
                        }
                    }
                }
                if (counts.FOREST < MIN_FOREST_TILES_SOFT && counts.FOREST < tileBudget.FOREST) {
                    for (const coord of allHexCoords) {
                        if (counts.FOREST >= MIN_FOREST_TILES_SOFT || counts.FOREST >= tileBudget.FOREST) break;
                        const key = getTileKey(coord.q, coord.r);
                        if (tempTiles.get(key) === TILE_TYPES.PLAINS) {
                            assignTile(coord.q, coord.r, TILE_TYPES.FOREST, counts);
                        }
                    }
                }
                if (counts.PLAINS < MIN_PLAINS_TILES_SOFT && counts.PLAINS < tileBudget.PLAINS) {
                     for (const coord of allHexCoords) {
                        if (counts.PLAINS >= MIN_PLAINS_TILES_SOFT || counts.PLAINS >= tileBudget.PLAINS) break;
                        const key = getTileKey(coord.q, coord.r);
                        if (tempTiles.get(key) === TILE_TYPES.FOREST && counts.FOREST > MIN_FOREST_TILES_SOFT) { 
                            assignTile(coord.q, coord.r, TILE_TYPES.PLAINS, counts);
                        }
                    }
                }
                allHexCoords.forEach(coord => {
                    const key = getTileKey(coord.q, coord.r);
                    const currentType = tempTiles.get(key);
                    if (currentType === TILE_TYPES.PLAINS) {
                        if (counts.FOREST < 5 && counts.FOREST < tileBudget.FOREST && Math.random() < 0.1) { 
                            assignTile(coord.q, coord.r, TILE_TYPES.FOREST, counts);
                        } else if (counts.WATER < 3 && counts.WATER < tileBudget.WATER && Math.random() < 0.05) { 
                             assignTile(coord.q, coord.r, TILE_TYPES.WATER, counts);
                        }
                    } else if (currentType === TILE_TYPES.FOREST) {
                         if (counts.MOUNTAIN < 2 && counts.MOUNTAIN < tileBudget.MOUNTAIN && axialDistance(coord.q, coord.r, 0,0) > 1 && Math.random() < 0.05) {
                            assignTile(coord.q, coord.r, TILE_TYPES.MOUNTAIN, counts);
                        }
                    }
                });
            }
            
            const originKey = getTileKey(0,0);
            let originTile = tempTiles.get(originKey);
            if (originTile === TILE_TYPES.WATER || originTile === TILE_TYPES.MOUNTAIN) {
                let swapped = false;
                const centralCandidates = allHexCoords.filter(c => axialDistance(c.q,c.r,0,0) <=1 && c.q !== 0 && c.r !==0);
                for(const candCoord of centralCandidates) {
                    const candKey = getTileKey(candCoord.q, candCoord.r);
                    const candTile = tempTiles.get(candKey);
                    if (candTile === TILE_TYPES.PLAINS || candTile === TILE_TYPES.FOREST) {
                        assignTile(0,0, candTile, counts); 
                        assignTile(candCoord.q, candCoord.r, originTile, counts);
                        swapped = true; break;
                    }
                }
                if (!swapped) assignTile(0,0, TILE_TYPES.PLAINS, counts); 
            }

            let centralPlainsCount = 0;
            const centralHexes = allHexCoords.filter(c => axialDistance(c.q,c.r,0,0) <=1);
            centralHexes.forEach(c => {
                if(tempTiles.get(getTileKey(c.q,c.r)) === TILE_TYPES.PLAINS) centralPlainsCount++;
            });

            if(centralPlainsCount < MIN_CENTRAL_PLAINS_SOFT) {
                const centralForestsToConvert = centralHexes.filter(c => tempTiles.get(getTileKey(c.q,c.r)) === TILE_TYPES.FOREST)
                                                       .sort(() => 0.5 - Math.random());
                for(const cfc of centralForestsToConvert) {
                    if(centralPlainsCount >= MIN_CENTRAL_PLAINS_SOFT || counts.PLAINS >= tileBudget.PLAINS) break;
                    assignTile(cfc.q, cfc.r, TILE_TYPES.PLAINS, counts);
                    centralPlainsCount++;
                }
            }
             allHexCoords.forEach(coord => { 
                if (tempTiles.get(getTileKey(coord.q, coord.r)) === null) {
                    assignTile(coord.q, coord.r, TILE_TYPES.PLAINS, counts);
                }
            });
            console.log("Final Tile Counts:", JSON.parse(JSON.stringify(counts))); 
            return tempTiles;
        }

        function placeUnitsOnNewGeneratedMap() {
            const landEdges = [];
            gameState.edges.forEach((edgeData, edgeKey) => {
                const tileCoords = parseEdgeKey(edgeKey);
                const tile1 = gameState.tiles.get(getTileKey(tileCoords[0].q, tileCoords[0].r));
                const tile2 = gameState.tiles.get(getTileKey(tileCoords[1].q, tileCoords[1].r));
                if (tile1 && tile2 && isLand(tile1.type) && isLand(tile2.type)) {
                    landEdges.push(edgeKey);
                }
            });

            if (landEdges.length < 8) {
                console.error(`CRITICAL: Not enough land edges (${landEdges.length}). Placing randomly.`);
                landEdges.sort(() => 0.5 - Math.random());
                const usedEdgesFallback = new Set();
                const allUnitTypes = [UNIT_TYPES.MELEE, UNIT_TYPES.ARCHER, UNIT_TYPES.PIKEMAN, UNIT_TYPES.HORSEMAN];

                const placeFallbackTeam = (player) => {
                    allUnitTypes.forEach(type => {
                        let placed = false;
                        for (const edgeKey of landEdges) {
                            if (!usedEdgesFallback.has(edgeKey)) {
                                gameState.units.push(createUnit(player, type, edgeKey));
                                usedEdgesFallback.add(edgeKey);
                                placed = true;
                                break;
                            }
                        }
                        if (!placed) console.error(`Could not place P${player} ${type.name}`);
                    });
                };
                placeFallbackTeam(1);
                placeFallbackTeam(2);
            } else {
                const p1CandidateEdges = [];
                const p2CandidateEdges = [];
                const hemisphereThresholdQ = 0;
                landEdges.forEach(edgeKey => {
                    const coords = parseEdgeKey(edgeKey);
                    const avgQ = (coords[0].q + coords[1].q) / 2;
                    if (avgQ < hemisphereThresholdQ) {
                        p1CandidateEdges.push({ key: edgeKey, q: avgQ });
                    } else {
                        p2CandidateEdges.push({ key: edgeKey, q: avgQ });
                    }
                });

                p1CandidateEdges.sort((a, b) => a.q - b.q);
                p2CandidateEdges.sort((a, b) => b.q - a.q);

                const usedEdges = new Set();
                const allUnitTypes = [UNIT_TYPES.MELEE, UNIT_TYPES.ARCHER, UNIT_TYPES.PIKEMAN, UNIT_TYPES.HORSEMAN];

                const placeTeam = (playerNum, candidates) => {
                    let placedCount = 0;
                    for (const cand of candidates) {
                        if (placedCount >= 4) break;
                        if (!usedEdges.has(cand.key)) {
                            gameState.units.push(createUnit(playerNum, allUnitTypes[placedCount], cand.key));
                            usedEdges.add(cand.key);
                            placedCount++;
                        }
                    }
                    while (placedCount < 4) {
                        const fallbackEdge = landEdges.find(e => !usedEdges.has(e));
                        if(fallbackEdge) {
                             gameState.units.push(createUnit(playerNum, allUnitTypes[placedCount], fallbackEdge));
                             usedEdges.add(fallbackEdge);
                             placedCount++;
                        } else {
                            console.error(`Ran out of all possible land edges placing for P${playerNum}`);
                            break;
                        }
                    }
                };

                placeTeam(1, p1CandidateEdges);
                placeTeam(2, p2CandidateEdges);
            }

            gameState.units.forEach(unit => {
                if (!unit || !unit.position) {
                    console.error(`Invalid unit/pos after placement:`, unit);
                    gameState.units = gameState.units.filter(u => u && u.id !== (unit ? unit.id : undefined));
                    return;
                }
                const edge = gameState.edges.get(unit.position);
                if (edge) {
                    if (edge.units.length < 2) {
                        edge.units.push(unit);
                    } else {
                        console.warn(`Unit ${unit.id} on full edge ${unit.position}. Occupants: ${edge.units.map(u=>u.id).join(', ')}.`);
                    }
                } else {
                    console.error("CRITICAL: Edge not found for unit pos:", unit.position, unit);
                }
            });
        }

        ui.downloadButton.addEventListener('click', () => {
            try {
                const pageHTML = document.documentElement.outerHTML; const blob = new Blob([pageHTML], { type: 'text/html' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'FortHex.html';
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
                showInstruction('Game HTML downloaded!', 2000);
            } catch (error) { console.error("Error downloading game:", error); showInstruction('Error downloading. See console.', 3000); }
        });

        if (ui.tutorialButton) {
            ui.tutorialButton.addEventListener('click', () => {
                if (ui.tutorialModalOverlay) {
                    ui.tutorialModalOverlay.style.display = 'flex'; 
                    setTimeout(() => {
                        ui.tutorialModalOverlay.classList.add('modal-visible');
                    }, 10); 
                }
            });
        }

        function closeTutorialModal() {
            if (ui.tutorialModalOverlay) {
                ui.tutorialModalOverlay.classList.remove('modal-visible');
                setTimeout(() => {
                    ui.tutorialModalOverlay.style.display = 'none';
                }, 300); 
            }
        }

        if (ui.tutorialCloseButton) {
            ui.tutorialCloseButton.addEventListener('click', closeTutorialModal);
        }
        if (ui.tutorialModalOverlay) {
            ui.tutorialModalOverlay.addEventListener('click', (event) => {
                if (event.target === ui.tutorialModalOverlay) { 
                    closeTutorialModal();
                }
            });
        }

        if (ui.tutorialSectionHeaders) {
            ui.tutorialSectionHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const arrow = header.querySelector('.tutorial-arrow');
                    const isActive = header.classList.contains('active');

                    ui.tutorialSectionHeaders.forEach(otherHeader => {
                        if (otherHeader !== header) {
                            otherHeader.classList.remove('active');
                            otherHeader.nextElementSibling.classList.remove('open');
                            const otherArrow = otherHeader.querySelector('.tutorial-arrow');
                            if (otherArrow) otherArrow.innerHTML = '&#9658;'; 
                        }
                    });

                    if (isActive) {
                        header.classList.remove('active');
                        content.classList.remove('open');
                        if (arrow) arrow.innerHTML = '&#9658;'; 
                    } else {
                        header.classList.add('active');
                        content.classList.add('open');
                        if (arrow) arrow.innerHTML = '&#9660;'; 
                    }
                });
            });
        }

        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        window.addEventListener('mouseup', handleCanvasMouseUp);
        canvas.addEventListener('mouseleave', handleCanvasMouseLeave);
        canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleCanvasTouchEnd);
        canvas.addEventListener('touchcancel', handleCanvasTouchCancel);

        window.onload = function () {
            // --- NEW: Add event listeners for the Respawn Modal Buttons ---
            const respawnChoicesDiv = document.getElementById('respawnChoices');
            if (respawnChoicesDiv) {
                respawnChoicesDiv.addEventListener('click', (event) => {
                    const button = event.target.closest('.respawn-button');
                    if (button) {
                        const unitTypeName = button.dataset.unitType;
                        const unitType = UNIT_TYPES[unitTypeName];
                        
                        if (unitType) {
                            const spawnSuccess = spawnUnit(gameState.currentPlayer, unitType);

                            if (spawnSuccess) {
                                const queueKey = `player${gameState.currentPlayer}`;
                                gameState.respawnQueue[queueKey].shift();
                                
                                hideRespawnModal();
                                updateRespawnQueueDisplay();
                            } else {
                                showInstruction("Could not spawn unit, base is blocked!", 3000);
                                hideRespawnModal();
                            }
                        }
                    }
                });
            }
            gameState.gridRadius = GRID_RADIUS; 
            initializeGrid(); 
            gameLoop();
            showInstruction("Project Hexblade Loaded. Player 1's Turn.", 3000);
        };
    </script>
</body></html>